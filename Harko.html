<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harko-Patterson Map Analysis</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; margin: 0; background-color: #f1f5f9; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        #app-container { display: flex; width: 100%; flex-grow: 1; min-height: 0; }
        #controls-panel {
            width: 450px;
            min-width: 400px;
            max-width: 600px;
            flex-shrink: 0;
            padding: 24px;
            background-color: #111827;
            border-right: 1px solid #374151;
            overflow-y: auto;
            color: #d1d5db;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 20;
        }
        #drag-handle { width: 6px; cursor: col-resize; background-color: #374151; flex-shrink: 0; transition: background-color 0.2s; }
        #drag-handle:hover { background-color: #3b82f6; }
        /* #results-area fills the remaining height */
        #results-area { flex-grow: 1; background-color: #f1f5f9; min-width: 0; padding: 1.5rem; color: #1f2937; }

        .control-group { margin-bottom: 1.5rem; padding-bottom: 1.5rem; border-bottom: 1px solid #374151;}
        .control-group:last-of-type { border-bottom: none; padding-bottom: 0; margin-bottom: 0;}
        .control-label { display: block; margin-bottom: 8px; font-weight: 500; color: #9ca3af; }

        .btn { display: inline-block; padding: 0.6rem 1rem; border-radius: 0.375rem; font-weight: 600; transition: background-color 0.2s; cursor: pointer; text-align: center; width: auto; }
        .btn-full { width: 100%; }
        .btn-primary { background-color: #3b82f6; color: white; }
        .btn-primary:hover { background-color: #2563eb; }
        .btn:disabled { background-color: #4b5563; color: #9ca3af; cursor: not-allowed; }

        .info-box { background-color: #1f2937; padding: 12px; border-radius: 8px; font-family: monospace; font-size: 0.8rem; line-height: 1.6; }
        
        /* Canvas wrapper: remove fixed width/aspect. Will be sized by flexbox in HTML. */
        .canvas-wrapper { background-color: #1e2937; box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.2); overflow: hidden; border-radius: 8px; }
        /* Canvas: remove fixed width/height. JS will set it. */
        canvas { display: block; }

        /* Styled Tables */
        .styled-table { width: 100%; font-size: 0.8rem; border-collapse: collapse; }
        .styled-table th, .styled-table td { text-align: left; padding: 8px 10px; font-family: monospace; color: #374151; }
        .styled-table thead th { color: #4b5563; border-bottom: 2px solid #d1d5db; }
        .styled-table tbody tr { border-bottom: 1px solid #e5e7eb; }
        .styled-table tbody tr:nth-of-type(even) { background-color: #f9fafb; }
        .styled-table tbody tr:hover { background-color: #eff6ff; }
        /* table-container gets height from flex parent */
        .table-container { overflow-y: auto; background-color: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.5rem; box-shadow: inset 0 1px 2px rgba(0,0,0,0.05); }

        .dark-table { width: 100%; }
        .dark-table th, .dark-table td { text-align: left; padding: 4px 8px; border-bottom: 1px solid #374151; font-family: monospace;}
        .dark-table th { color: #9ca3af; }
        .dark-table tbody tr:hover { background-color: #374151; }
        .dark-table-container { flex-grow: 1; overflow-y: auto; background-color: #111827; border: 1px solid #374151; border-radius: 0.5rem; box-shadow: inset 0 1px 2px rgba(0,0,0,0.05); }


        body.resizing { cursor: col-resize !important; user-select: none; }

        /* Left Panel Tabs */
        .left-tabs { display: flex; border-bottom: 1px solid #374151; margin-bottom: 1.5rem; }
        .left-tab-button {
            padding: 0.5rem 1rem; font-weight: 600; color: #9ca3af; background-color: transparent;
            border: none; border-bottom: 2px solid transparent; cursor: pointer; transition: all 0.2s;
        }
        .left-tab-button:hover:not(.left-tab-active):not(:disabled) { color: #d1d5db; border-color: #4b5563; }
        .left-tab-button.left-tab-active { color: #3b82f6; border-color: #3b82f6; }
        .left-tab-button:disabled { color: #4b5563; cursor: not-allowed; }
        .left-tab-content { display: none; flex-grow: 1; flex-direction: column;}
        .left-tab-content.active { display: flex; }

        /* Tooltip (opens down) */
        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 320px; /* Made wider */
            background-color: #333;
            color: #fff;
            text-align: left; /* Changed to left-aligned */
            border-radius: 6px;
            padding: 12px 16px; /* Increased padding */
            position: absolute;
            z-index: 100;
            top: 150%;
            left: 0;
            margin-left: 0; 
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.85rem;
            line-height: 1.5; /* Slightly increased line-height */
        }
        .tooltip .tooltiptext a {
            color: #93c5fd; /* Tailwind blue-300 */
            text-decoration: none;
        }
        .tooltip .tooltiptext a:hover {
            color: #ffffff;
            text-decoration: underline;
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            bottom: 100%;
            left: 15%;
            margin-left: 0;
            border-width: 5px;
            border-style: solid;
            border-color: transparent transparent #333 transparent;
        }

.tooltip .tooltiptext.visible {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="controls-panel">



<div class="control-group flex items-center">
    <div class="tooltip mr-2"> <span id="tooltip-icon" class="flex items-center justify-center w-9 h-9 text-lg font-bold text-gray-200 bg-gray-600 rounded-full cursor-pointer select-none">?</span>
        
        <span id="tooltip-text" class="tooltiptext">Load a Pawley refinement output file (.dat or .txt), generated by Powder5 or a similar program. This file must contain the unit cell, space group, and a list of reflection intensities.
        <br><br>
        The program uses internal definitions for Harker sections based on 'space_groups_harker.json'.
        <br><br>
        For full technical details on the method and program usage, <a href="harko_help.html" target="_blank"><b>open the full help guide</b></a>.
        </span>
    </div>
    
    <button id="open-file-btn" class="btn btn-primary flex-grow">Select Data File</button>

    <input type="file" id="data-file-input" class="hidden"/>
</div>




            <div id="status-message" class="text-sm text-amber-400 -mt-4 mb-4 h-4"></div>

            <div class="flex-grow flex flex-col">
                <div class="left-tabs">
                    <button class="left-tab-button left-tab-active" data-tab="map-controls-tab">Map</button>
                    <button class="left-tab-button" data-tab="slices-controls-tab" disabled>Slices</button>
                    <button class="left-tab-button" data-tab="peaks-controls-tab" disabled>Peaks</button>
                </div>

                <div id="map-controls-tab" class="left-tab-content active">
                    <div class="control-group">
                        <label class="control-label">Crystal & Refinement Data</label>
                        <div id="crystal-info-box" class="info-box min-h-[120px]">Upload a file to see data.</div>
                    </div>
                   
                    <div class="control-group">
                        <label class="control-label">Patterson Map Calculation</label>
                        <div>
                            <label for="resolution-slider" class="block mb-2 text-sm font-medium">Map Resolution: <span id="resolution-value" class="font-bold">50</span></label>
                            <input type="range" id="resolution-slider" min="20" max="100" value="50" step="2" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer" disabled>
                        </div>
                        
                        <!-- *** Cosine Taper Checkbox Removed *** -->

                    </div>
                </div>

                <div id="slices-controls-tab" class="left-tab-content">
                     <div class="control-group">
                        <label class="control-label">Slice Controls</label>
                        <div class="space-y-4">
                            <div>
                                <label for="slice-slider-u" class="block mb-2 text-sm font-medium">Slice Position U: <span id="slice-value-u" class="font-bold">0.500</span></label>
                                <input type="range" id="slice-slider-u" min="0" max="1" value="0.5" step="0.02" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer" disabled>
                            </div>
                            <div>
                                <label for="slice-slider-v" class="block mb-2 text-sm font-medium">Slice Position V: <span id="slice-value-v" class="font-bold">0.500</span></label>
                                <input type="range" id="slice-slider-v" min="0" max="1" value="0.5" step="0.02" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer" disabled>
                            </div>
                            <div>
                                <label for="slice-slider-w" class="block mb-2 text-sm font-medium">Slice Position W: <span id="slice-value-w" class="font-bold">0.500</span></label>
                                <input type="range" id="slice-slider-w" min="0" max="1" value="0.5" step="0.02" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer" disabled>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="peaks-controls-tab" class="left-tab-content flex-grow flex flex-col">
                    <div class="control-group">
                        <label class="control-label">Peak Analysis</label>
                        <div>
                            <label for="tolerance-slider" class="block mb-2 text-sm font-medium">Combination Tolerance: <span id="tolerance-value" class="font-bold">0.030</span></label>
                            <input type="range" id="tolerance-slider" min="0.01" max="0.10" value="0.03" step="0.005" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer" disabled>
                        </div>
                    </div>
                     <div class="control-group flex-grow flex flex-col">
                        <h3 class="font-semibold text-gray-300 mb-2">Heavy Atom Sites (Partial)</h3>
                        <div id="sites-table-container" class="dark-table-container flex-grow">
                            <table class="w-full dark-table">
                                <thead class="sticky top-0 bg-gray-800"><tr><th>Source</th><th>(x, y, z)</th></tr></thead>
                                <tbody id="sites-table-body"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <button id="generate-report-btn" class="btn btn-primary btn-full mt-auto" disabled>Generate PDF Report</button>
        </div>

        <div id="drag-handle"></div>

        <!-- This grid now fills the height of the parent container -->
        <div id="results-area" class="grid grid-cols-1 md:grid-cols-3 gap-6 h-full">
            
            <!-- Left column (canvas) is a flex column that can shrink -->
            <div class="md:col-span-2 flex flex-col min-h-0">
                 <h2 id="slice-title" class="text-lg font-semibold text-center mb-3 flex-shrink-0">Patterson Map Slice</h2>
                 <!-- Canvas wrapper grows/shrinks and centers the canvas -->
                 <div class="canvas-wrapper flex-grow min-h-0 flex items-center justify-center">
                    <canvas id="patterson-canvas"></canvas>
                 </div>
                 <div id="coords-display" class="font-mono text-sm text-center mt-2 h-5 text-slate-600 flex-shrink-0"></div>
            </div>

            <!-- Right column (tables) fills height and splits internally -->
            <div class="flex flex-col min-h-0 gap-6">
                 <!-- Wrapper 1: 2/3 height (flex-[2]) -->
                 <div class="flex flex-col flex-[2] min-h-0">
                    <h2 class="text-lg font-semibold text-center mb-3 flex-shrink-0">Patterson Peaks</h2>
                    <!-- table-container scrolls -->
                    <div class="table-container flex-1 min-h-0">
                        <table id="peaks-table" class="styled-table">
                            <thead><tr><th>Height</th><th>(u, v, w)</th></tr></thead>
                            <tbody id="peaks-table-body"></tbody>
                        </table>
                    </div>
                 </div>
                 <!-- Wrapper 2: 1/3 height (flex-1) -->
                 <div class="flex flex-col flex-1 min-h-0">
                    <h2 class="text-lg font-semibold text-center mb-3 flex-shrink-0">Consolidated Atom Sites</h2>
                    <!-- table-container scrolls -->
                    <div class="table-container flex-1 min-h-0">
                        <table id="consolidated-sites-table" class="styled-table">
                            <thead><tr><th>(x, y, z)</th></tr></thead>
                            <tbody id="consolidated-sites-table-body"></tbody>
                        </table>
                    </div>
                 </div>
            </div>
        </div>
    </div>

    <footer class="fixed bottom-0 right-0 p-2 text-xs text-slate-400">Harker sections in Patterson maps. v 26 oct 2025. NitaD, Univ Paris-Saclay.</footer> <!-- Version bump -->

<script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM ELEMENTS ---
        const openFileBtn = document.getElementById('open-file-btn');
        const fileInput = document.getElementById('data-file-input');
        const tooltipIcon = document.getElementById('tooltip-icon');
        const tooltipText = document.getElementById('tooltip-text');
        const statusMessage = document.getElementById('status-message');
        const crystalInfoBox = document.getElementById('crystal-info-box');
        const resolutionSlider = document.getElementById('resolution-slider');
        const resolutionValue = document.getElementById('resolution-value');
        const sliceSliderU = document.getElementById('slice-slider-u'), sliceValueU = document.getElementById('slice-value-u');
        const sliceSliderV = document.getElementById('slice-slider-v'), sliceValueV = document.getElementById('slice-value-v');
        const sliceSliderW = document.getElementById('slice-slider-w'), sliceValueW = document.getElementById('slice-value-w');
        const sliceTitle = document.getElementById('slice-title');
        const toleranceSlider = document.getElementById('tolerance-slider');
        const toleranceValue = document.getElementById('tolerance-value');
        const peaksTableBody = document.getElementById('peaks-table-body');
        const sitesTableBody = document.getElementById('sites-table-body');
        const consolidatedSitesTableBody = document.getElementById('consolidated-sites-table-body');
        const pattersonCanvas = document.getElementById('patterson-canvas');
        const coordsDisplay = document.getElementById('coords-display');
        const pattersonCtx = pattersonCanvas.getContext('2d');
        const generateReportBtn = document.getElementById('generate-report-btn');
        const leftTabButtons = document.querySelectorAll('.left-tab-button');
        const leftTabContents = document.querySelectorAll('.left-tab-content');

        // --- STATE (Main Thread) ---
        let state = {
            crystalData: null, spaceGroups: null, pattersonMap3D: null, fileName: null,
            mapResolution: 50, harkerTolerance: 0.03,
            foundPeaks: [], harkerAnalysisResults: [], consolidatedSites: [],
            sliceU: 0.5, sliceV: 0.5, sliceW: 0.5,
            activeSlicingAxis: 'w',
        };

        // --- WEB WORKER ---
        let pattersonWorker;

        // --- INITIALIZATION ---
        try {
             pattersonWorker = new Worker('harko_worker.js');
             
             // --- WORKER MESSAGE HANDLER ---
             pattersonWorker.onmessage = (e) => {
                const { type, payload } = e.data;

                if (type === 'status') {
                    // Update status message as worker progresses
                    statusMessage.textContent = payload;
                    statusMessage.classList.remove('text-red-500', 'text-green-500');
                    statusMessage.classList.add('text-amber-400');
                }
                else if (type === 'analysis_complete') {
                    // --- FINAL RESULTS ARE IN ---
                    console.log("Analysis complete. Receiving results from worker.");
                    
                    // Store all results in state
                    state.pattersonMap3D = payload.pattersonMap3D;
                    state.foundPeaks = payload.foundPeaks;
                    state.harkerAnalysisResults = payload.harkerAnalysisResults;
                    state.consolidatedSites = payload.consolidatedSites;

                    // Update UI
                    updateAllTables();
                    resizeCanvas(); // Resize canvas now that we have a map
                    drawPattersonSlice();

                    // Update status and cursor
                    document.body.style.cursor = 'default';
                    statusMessage.textContent = payload.finalMessage;
                    if (payload.consolidatedSites.length > 0) {
                        statusMessage.classList.add('text-green-500');
                        statusMessage.classList.remove('text-amber-400');
                    }
                    
                    // Re-enable all UI elements
                    updateUIStates();
                }
                else if (type === 'error') {
                    // Handle errors from the worker
                    console.error("Worker Error:", payload);
                    statusMessage.textContent = `Error: ${payload}`;
                    statusMessage.classList.add('text-red-500');
                    document.body.style.cursor = 'default';
                    updateUIStates();
                }
             };

             pattersonWorker.onerror = (error) => {
                console.error("Worker failed to load or threw an unhandled error:", error);
                statusMessage.textContent = `Critical Worker Error: ${error.message}. Try reloading.`;
                statusMessage.classList.add('text-red-500');
                document.body.style.cursor = 'default';
                // Disable everything
                resolutionSlider.disabled = true;
                leftTabButtons.forEach(b => b.disabled = true);
             };

        } catch (err) {
            console.error("Failed to initialize Web Worker:", err);
            statusMessage.textContent = "Error: Could not initialize analysis engine (Worker).";
            statusMessage.classList.add('text-red-500');
        }

        // --- Fetch Harker data (main thread) ---
        fetch('space_groups_harker.json')
            .then(response => {
                if (!response.ok) {
                    if (response.status === 404) {
                         throw new Error("space_groups_harker.json not found. Place it in the same directory.");
                    }
                    throw new Error(`HTTP error ${response.status} loading space_groups_harker.json`);
                }
                return response.json();
            })
            .then(data => {
                state.spaceGroups = data;
                console.log("Harker data loaded.");
                 statusMessage.textContent = "Harker definitions loaded.";
                 statusMessage.classList.remove('text-red-500');
                 statusMessage.classList.add('text-green-500');
                 setTimeout(() => { if (statusMessage.textContent === "Harker definitions loaded.") statusMessage.textContent = ''; }, 3000);
            })
            .catch(error => {
                console.error("Error loading space_groups_harker.json:", error);
                statusMessage.textContent = `Error: ${error.message}`;
                statusMessage.classList.remove('text-amber-400', 'text-green-500');
                statusMessage.classList.add('text-red-500');
            })
            .finally(() => {
                updateUIStates();
            });


        resizeCanvas();
        updateUIStates();
        updateAllTables();

        // --- UI UTILS (Main Thread) ---
        function updateUIStates() {
            const hasHarkerData = !!state.spaceGroups;
            const hasCrystalData = !!state.crystalData;
            const hasMap = !!state.pattersonMap3D;
            const hasConsolidatedSites = state.consolidatedSites.length > 0;

            // Check if worker is busy (by checking if cursor is 'wait')
            const isBusy = document.body.style.cursor === 'wait';

            resolutionSlider.disabled = !hasCrystalData || isBusy;
            [sliceSliderU, sliceSliderV, sliceSliderW].forEach(s => s.disabled = !hasMap || isBusy);
            toleranceSlider.disabled = state.harkerAnalysisResults.length < 2 || isBusy;

            leftTabButtons.forEach(btn => {
                const tab = btn.dataset.tab;
                if (isBusy) {
                    btn.disabled = true; // Disable all tabs while busy
                } else {
                    // Enable/disable based on state
                    if (tab.includes('map')) { btn.disabled = !hasCrystalData; } 
                    else if (tab.includes('slices')) { btn.disabled = !hasMap; }
                    else if (tab.includes('peaks')) { btn.disabled = !hasMap || !hasHarkerData; }
                }
            });

            generateReportBtn.disabled = !hasConsolidatedSites || isBusy;
        }


        function showLeftTab(tabId) {
            leftTabContents.forEach(content => content.classList.remove('active'));
            leftTabButtons.forEach(button => button.classList.remove('left-tab-active'));
            document.getElementById(tabId).classList.add('active');
            document.querySelector(`.left-tab-button[data-tab="${tabId}"]`).classList.add('left-tab-active');
        }

        // --- PARSING (Main Thread) ---
        function parsePawleyFile(text) {
            console.log("Parsing file...");
            const data = { cell: {}, reflections: [], spaceGroup: null };
            const cellRegex = /^\s*([a-zA-Z]+)\s*\(.*\)\s+([\d.eE+-]+)/;
            const spaceGroupRegex = /Space Group:\s+(\d+)\s*[-–]\s*(.+)/;
            const reflectionRegex = /^\(\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(-?\d+)\s*\)\s+[\d.]+\s+([\d.]+)/;
            let inReflectionsSection = false;
            const lines = text.split('\n');

            for (let i = 0; i < lines.length; i++) {
                const originalLine = lines[i]; const line = originalLine.trim();
                if (line.includes('--- Reflections List')) { inReflectionsSection = true; continue; }
                if (line.includes('--- Point-by-Point Intensity Data')) { break; }
                if (!inReflectionsSection) {
                    let cellMatch = line.match(cellRegex);
                    if (cellMatch) { data.cell[cellMatch[1]] = parseFloat(cellMatch[2]); continue; }
                    if (!data.spaceGroup) {
                         let spaceGroupMatch = line.match(spaceGroupRegex);
                        if (spaceGroupMatch) { data.spaceGroup = { number: parseInt(spaceGroupMatch[1]), name: spaceGroupMatch[2].trim() }; console.log(` Found space group: ${data.spaceGroup.number}`); }
                    }
                } else {
                    const reflectionMatch = line.match(reflectionRegex);
                    if (reflectionMatch) {
                        try {
                            const h = parseInt(reflectionMatch[1].trim()); 
                            const k = parseInt(reflectionMatch[2].trim()); 
                            const l = parseInt(reflectionMatch[3].trim()); 
                            const intensity = parseFloat(reflectionMatch[4]);
                            const reflection = { h, k, l, intensity };
                            if (!isNaN(h) && !isNaN(k) && !isNaN(l) && !isNaN(intensity)) {
                                data.reflections.push(reflection); 
                            }
                            else { console.warn(`Skipped reflection (NaN):`, originalLine); }
                        } catch (parseError) { console.error(`Error parsing reflection: "${originalLine}"`, parseError); }
                    }
                }
            }

            if (!data.cell.hasOwnProperty('alpha')) data.cell.alpha = 90;
            if (!data.cell.hasOwnProperty('beta')) data.cell.beta = 90;
            if (!data.cell.hasOwnProperty('gamma')) data.cell.gamma = 90;
            if (data.cell.hasOwnProperty('a') && !isNaN(data.cell.a)) {
                if (!data.cell.hasOwnProperty('b') || isNaN(data.cell.b)) { data.cell.b = data.cell.a; console.log(` Inferred b=a`); }
                if (!data.cell.hasOwnProperty('c') || isNaN(data.cell.c)) { data.cell.c = data.cell.a; console.log(` Inferred c=a`); }
            }

            if (!data.spaceGroup) { throw new Error("Could not parse Space Group."); }
            if (!data.cell.a || isNaN(data.cell.a) || !data.cell.b || isNaN(data.cell.b) || !data.cell.c || isNaN(data.cell.c)) { throw new Error("Could not determine cell parameters (a, b, c)."); }
            if (data.reflections.length === 0 && inReflectionsSection) { console.warn("No reflections parsed."); }
            
            console.log(`Parsed ${data.reflections.length} reflections.`);
            return data;
        }

        // --- HEAVY CALCULATION FUNCTIONS (REMOVED) ---
        // calculatePattersonMap, findPeaks, analyzeHarkerPeaks, combineSites,
        // solveCoordinate, averagePeriodic, adjustPeriodic are all GONE from here.
        // They now live in harko_worker.js.
        
        // --- UI & DRAWING (Main Thread) ---
        function updateCrystalInfo() {
            if (!state.crystalData) { crystalInfoBox.innerHTML = 'Upload file.'; return; }
            const { cell, spaceGroup, reflections } = state.crystalData;
            const sgInfo = spaceGroup ? `${spaceGroup.number} (${spaceGroup.name})` : '<span class="text-red-500">N/A</span>';
            crystalInfoBox.innerHTML = `<strong>SG:</strong> ${sgInfo}<br>
            <strong>Cell:</strong> a=${cell.a?.toFixed(4)}, b=${cell.b?.toFixed(4)}, c=${cell.c?.toFixed(4)}<br>
            <strong>Ang:</strong> α=${cell.alpha?.toFixed(1)}°, β=${cell.beta?.toFixed(1)}°, γ=${cell.gamma?.toFixed(1)}°<br>
            <strong>Refls:</strong> ${reflections?.length || 0}`;
        }

        function drawPattersonSlice() {
            if (!state.pattersonMap3D) { pattersonCtx.fillStyle='#1e2937'; pattersonCtx.fillRect(0,0,pattersonCanvas.width,pattersonCanvas.height); return; }
            const res=state.mapResolution, map=state.pattersonMap3D, axis=state.activeSlicingAxis;
            const u_idx=Math.round(state.sliceU*(res-1)),v_idx=Math.round(state.sliceV*(res-1)),w_idx=Math.round(state.sliceW*(res-1));

             let sliceMin=Infinity, sliceMax=-Infinity; let isValidSlice = false;
             for(let i=0; i<res; i++) for(let j=0; j<res; j++) {
                 let idx;
                 if (axis === 'u') idx = j*res*res + i*res + u_idx;
                 else if (axis === 'v') idx = j*res*res + v_idx*res + i;
                 else idx = w_idx*res*res + j*res + i;
                 if (idx >= 0 && idx < map.length && isFinite(map[idx])) { isValidSlice = true; if(map[idx]<sliceMin) sliceMin=map[idx]; if(map[idx]>sliceMax) sliceMax=map[idx]; }
             }
             if (!isValidSlice || sliceMax === sliceMin) { pattersonCtx.fillStyle='#1e2937'; pattersonCtx.fillRect(0,0,pattersonCanvas.width,pattersonCanvas.height); return; }

            const size=pattersonCanvas.width, img=pattersonCtx.createImageData(size,size), data=img.data; const range = sliceMax - sliceMin;
            for(let py=0; py<size; py++) for(let px=0; px<size; px++) {
                let map_x, map_y, fixed_idx, idx;
                if (axis === 'u') { map_x = Math.floor(px / size * res); map_y = Math.floor((1 - py / size) * res); fixed_idx = u_idx; idx = map_y * res * res + map_x * res + fixed_idx; }
                else if (axis === 'v') { map_x = Math.floor(px / size * res); map_y = Math.floor((1 - py / size) * res); fixed_idx = v_idx; idx = map_y * res * res + fixed_idx * res + map_x; }
                else { map_x = Math.floor(px / size * res); map_y = Math.floor((1 - py / size) * res); fixed_idx = w_idx; idx = fixed_idx*res*res + map_y*res + map_x; }
                const d_idx=(py*size+px)*4;
                if (idx < 0 || idx >= map.length || !isFinite(map[idx])) { data[d_idx]=30; data[d_idx+1]=41; data[d_idx+2]=59; data[d_idx+3]=255; continue; };
                const val = range > 1e-9 ? (map[idx]-sliceMin)/range : 0.5; let r=0, g=0, b=0;
                if (val < 0.25) { r = 0; g = Math.max(0, Math.min(255, Math.round(4 * val * 255))); b = 255; }
                else if (val < 0.5) { r = 0; g = 255; b = Math.max(0, Math.min(255, Math.round((1 - 4 * (val - 0.25)) * 255))); }
                else if (val < 0.75) { r = Math.max(0, Math.min(255, Math.round(4 * (val - 0.5) * 255))); g = 255; b = 0; }
                else { r = 255; g = Math.max(0, Math.min(255, Math.round((1 - 4 * (val - 0.75)) * 255))); b = 0; }
                data[d_idx]=r; data[d_idx+1]=g; data[d_idx+2]=b; data[d_idx+3]=255;
            }
            pattersonCtx.putImageData(img,0,0);
        }


        function updateAllTables() {
            try { peaksTableBody.innerHTML = state.foundPeaks.length === 0 ? '<tr><td colspan="2" class="text-center py-8">No peaks.</td></tr>' : state.foundPeaks.map(p => `<tr><td>${p.height.toFixed(2)}</td><td>(${p.u.toFixed(3)}, ${p.v.toFixed(3)}, ${p.w.toFixed(3)})</td></tr>`).join(''); } catch (e) { console.error("Err peaks table:", e); }
            try { sitesTableBody.innerHTML = state.harkerAnalysisResults.length === 0 ? '<tr><td colspan="2" class="text-center py-4">No partial sites.</td></tr>' : state.harkerAnalysisResults.map(s => `<tr><td class="text-xs">${s.source}</td><td>(${s.x}, ${s.y}, ${s.z})</td></tr>`).join(''); } catch (e) { console.error("Err sites table:", e); }
            try { consolidatedSitesTableBody.innerHTML = state.consolidatedSites.length === 0 ? '<tr><td class="text-center py-8">No sites combined.</td></tr>' : state.consolidatedSites.map(s => `<tr><td>(${s.x.toFixed(3)}, ${s.y.toFixed(3)}, ${s.z.toFixed(3)}) [${s.count}]</td></tr>`).join(''); } catch (e) { console.error("Err combined table:", e); }
        }

        function resizeCanvas() { 
            try { 
                const p = pattersonCanvas.parentElement; 
                if (!p) return; 
                const s = Math.min(p.clientWidth, p.clientHeight) - 4; 
                if (s <= 0) return; 
                pattersonCanvas.width = s; 
                pattersonCanvas.height = s; 
                pattersonCanvas.style.width = `${s}px`;
                pattersonCanvas.style.height = `${s}px`;
                drawPattersonSlice(); 
            } catch(e) { 
                console.error("Resize err:", e); 
            } 
        }

        function resetAnalysis(isNewFile = false) {
             console.log(`Resetting. New file: ${isNewFile}`);
            if(isNewFile) { state.crystalData = null; updateCrystalInfo(); }
            state.pattersonMap3D=null; state.foundPeaks=[]; state.harkerAnalysisResults=[]; state.consolidatedSites=[];
            
            updateAllTables(); 
            
            try {
                pattersonCtx.fillStyle='#1e2937'; 
                pattersonCtx.fillRect(0,0,pattersonCanvas.width,pattersonCanvas.height);
            } catch (e) {}

            showLeftTab('map-controls-tab');
            statusMessage.textContent = isNewFile ? '' : (statusMessage.textContent.startsWith("Error:") ? statusMessage.textContent : '');
             sliceSliderU.value = 0.5; sliceValueU.textContent = (0.5).toFixed(3); state.sliceU = 0.5;
             sliceSliderV.value = 0.5; sliceValueV.textContent = (0.5).toFixed(3); state.sliceV = 0.5;
             sliceSliderW.value = 0.5; sliceValueW.textContent = (0.5).toFixed(3); state.sliceW = 0.5;
             state.activeSlicingAxis = 'w'; sliceTitle.textContent = `Slice \u22a5 W at 0.500`; // Unicode fix
             toleranceSlider.value = 0.03; toleranceValue.textContent = (0.03).toFixed(3); state.harkerTolerance = 0.03;
             
             if (isNewFile) {
                resolutionSlider.value = 50; resolutionValue.textContent = 50; state.mapResolution = 50;
             }
             
             updateUIStates();
             resizeCanvas(); 
        }

        async function generatePdfReport() {
            if(!state.crystalData || state.consolidatedSites.length===0) { console.warn("PDF Skip: No data/sites."); statusMessage.textContent = "Cannot gen report: No consolidated sites."; setTimeout(() => { if(statusMessage.textContent.includes("Cannot gen report")) statusMessage.textContent = '';}, 3000); return; }
            console.log("Generating PDF report...");
            try {
                const { jsPDF } = window.jspdf; const doc = new jsPDF({ format: 'a4', unit: 'mm' }); let y=15; const m=10, lh=5; const pageH = doc.internal.pageSize.getHeight(); const pageW = doc.internal.pageSize.getWidth(); const contentW = pageW - 2 * m;
                doc.setFontSize(16); doc.text("Patterson Analysis Report", m, y); y+=lh*2; const now = new Date(); const ts = `${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}_${String(now.getHours()).padStart(2,'0')}${String(now.getMinutes()).padStart(2,'0')}${String(now.getSeconds()).padStart(2,'0')}`;
                doc.setFontSize(9); doc.text(`Date: ${now.toLocaleString()} | File: ${state.fileName||'N/A'}`, m, y); y+=lh*2;
                 const {cell,spaceGroup,reflections}=state.crystalData; const sgInfo = spaceGroup ? `${spaceGroup.number} (${spaceGroup.name})` : 'N/A';
                 doc.autoTable({ startY: y, theme: 'striped', headStyles: { fillColor: [75, 85, 99], fontSize: 8 }, bodyStyles: { fontSize: 7 }, columnStyles: { 0: { cellWidth: 40 }, 1: { cellWidth: 'auto'} }, head: [['Parameter', 'Value']],
                    body: [ 
                        ['SG', sgInfo], 
                        ['Cell (Å)', `${cell.a?.toFixed(4)}, ${cell.b?.toFixed(4)}, ${cell.c?.toFixed(4)}`], 
                        ['Ang (°)', `${cell.alpha?.toFixed(1)}, ${cell.beta?.toFixed(1)}, ${cell.gamma?.toFixed(1)}`], 
                        ['Refls', reflections?.length||0], 
                        ['Res', state.mapResolution], 
                        ['Tol', state.harkerTolerance.toFixed(3)],
                    ] });
                 y=doc.autoTable.previous.finalY+lh*2;
                doc.setFontSize(11); doc.text("Active Patterson Map Slice", m, y); y+=lh; const canvas=pattersonCanvas; const canvasDU = await html2canvas(canvas).then(can => can.toDataURL('image/png')); const imgW = contentW * 0.6; const imgH = (canvas.height * imgW) / canvas.width;
                 if (y + imgH > pageH - m) { doc.addPage(); y = m + lh; } doc.addImage(canvasDU, 'PNG', m, y, imgW, imgH); y += imgH + lh; doc.setFontSize(8); doc.text(`Slice \u22a5 ${state.activeSlicingAxis.toUpperCase()} at ${state[`slice${state.activeSlicingAxis.toUpperCase()}`].toFixed(3)}`, m, y); y += lh * 2; // Unicode fix
                 if (state.foundPeaks.length > 0) { if (y + 30 > pageH - m) { doc.addPage(); y = m + lh; } doc.setFontSize(11); doc.text("Found Patterson Peaks", m, y); y += lh; doc.autoTable({ html: '#peaks-table', startY: y, theme: 'grid', headStyles: { fillColor: [75, 85, 99], fontSize: 8 }, bodyStyles: { fontSize: 7, cellPadding: 1.5 }, tableWidth: 'wrap' }); y = doc.autoTable.previous.finalY + lh * 2; }
                 if(state.consolidatedSites.length > 0) { if (y + 30 > pageH - m) { doc.addPage(); y = m + lh; } doc.setFontSize(11); doc.text("Consolidated Sites", m, y); y += lh; const tc = document.getElementById('consolidated-sites-table').cloneNode(true); const pb = tc.querySelector('tbody'); pb.innerHTML = state.consolidatedSites.map(s => `<tr><td>(${s.x.toFixed(3)}, ${s.y.toFixed(3)}, ${s.z.toFixed(3)})</td></tr>`).join(''); doc.autoTable({ html: tc, startY: y, theme: 'grid', headStyles: { fillColor: [22, 163, 74], fontSize: 8 }, bodyStyles: { fontSize: 7, cellPadding: 1.5 }, tableWidth: 'wrap' }); y = doc.autoTable.previous.finalY + lh * 2; }
                 
                 // --- PDF PARTIAL SITES FIX ---
                 if (state.harkerAnalysisResults.length > 0) { 
                    if (y + 30 > pageH - m) { doc.addPage(); y = m + lh; } 
                    doc.setFontSize(11); doc.text("Partial Sites (Harker)", m, y); y += lh; 
                    const tc_partial = document.getElementById('sites-table-container').querySelector('table').cloneNode(true);
                    const pb_partial = tc_partial.querySelector('tbody');
                    pb_partial.innerHTML = state.harkerAnalysisResults.map(s => {
                        return `<tr><td style="font-size: 7pt;">${s.source}</td><td style="font-size: 7pt;">(${s.x}, ${s.y}, ${s.z})</td></tr>`;
                    }).join('');
                    if (y + 40 > pageH - m) { doc.addPage(); y = m + lh; } 
                    doc.autoTable({ html: tc_partial, startY: y, theme: 'grid', headStyles: { fillColor: [100, 116, 139], fontSize: 8 }, bodyStyles: { fontSize: 6, cellPadding: 1 }, tableWidth: 'auto' }); 
                 }
                 // --- END FIX ---

                doc.save(`Patterson_Report_${ts}.pdf`); console.log("PDF generated.");
            } catch (error) { console.error("PDF Error:", error); statusMessage.textContent = "Error generating PDF."; setTimeout(() => { if(statusMessage.textContent.includes("Error generating PDF")) statusMessage.textContent = '';}, 3000); }
        }


        // --- MAIN ANALYSIS FUNCTION (NOW SENDS TO WORKER) ---
        function runMapCalculationAndAnalysis() {
            if (!state.crystalData) { console.error("Run Skip: No data."); statusMessage.textContent = "Error: Load data."; return; }
            if (!state.spaceGroups) { console.error("Run Skip: No Harker defs."); statusMessage.textContent = "Error: Harker defs missing."; return; }
             if (!pattersonWorker) { console.error("Run Skip: Worker not initialized."); statusMessage.textContent = "Error: Worker not ready."; return; }
            
             console.log("=== Starting Full Analysis (Posting to Worker) ===");
             
             // Set busy state ON THE MAIN THREAD
             document.body.style.cursor = 'wait'; 
             statusMessage.textContent = `Calculating ${state.mapResolution}^3 map...`; 
             statusMessage.classList.remove('text-red-500', 'text-green-500'); 
             statusMessage.classList.add('text-amber-400');
             
             // Disable UI
             updateUIStates();
             
             // Clear old map-dependent data
             resetAnalysis(false); 
             
             // Update slice slider step *before* calculation
             const step = 1 / state.mapResolution;
             [sliceSliderU, sliceSliderV, sliceSliderW].forEach(s => s.step = Math.max(0.001, step).toFixed(4));
             
             // --- SEND DATA TO WORKER ---
             pattersonWorker.postMessage({
                type: 'CALCULATE',
                payload: {
                    crystalData: state.crystalData,
                    spaceGroups: state.spaceGroups,
                    mapResolution: state.mapResolution,
                    harkerTolerance: state.harkerTolerance
                }
             });
        }


        // --- EVENT HANDLERS ---
        openFileBtn.addEventListener('click',()=>fileInput.click());
        
        fileInput.addEventListener('change', async e => {
             const f = e.target.files[0]; if(!f) return; 
             console.clear(); 
             console.log(`Loading: ${f.name}`); 
             state.fileName=f.name; 
             const r=new FileReader();
             
             r.onload = ev => {
                 try{ 
                     resetAnalysis(true); // Full reset for new file
                     state.crystalData = parsePawleyFile(ev.target.result);
                     
                     if (!state.crystalData || !state.crystalData.spaceGroup || !state.crystalData.cell.a || !state.crystalData.cell.b || !state.crystalData.cell.c) { 
                         throw new Error("Parsing failed (SG or Cell). Check logs."); 
                     }
                     
                     if (!state.crystalData.reflections || state.crystalData.reflections.length === 0) { 
                         console.warn("No reflections parsed."); 
                         statusMessage.textContent = `Warn: ${f.name} loaded, no reflections.`; 
                         statusMessage.classList.remove('text-green-500'); 
                         statusMessage.classList.add('text-amber-400');
                     }
                     else { 
                         statusMessage.textContent=`${f.name} loaded. Ready.`; 
                         statusMessage.classList.remove('text-red-500','text-amber-400'); 
                         statusMessage.classList.add('text-green-500'); 
                     }
                     
                     updateCrystalInfo();
                     
                     // --- AUTO-CALCULATE LOGIC ---
                     state.mapResolution = 50; // Set default resolution
                     resolutionSlider.value = 50;
                     resolutionValue.textContent = '50';
                     
                     // Run initial calculation
                     runMapCalculationAndAnalysis(); 

                 } catch(err) { 
                     console.error("File processing error:", err); 
                     statusMessage.textContent = `Error: ${err.message}`; 
                     statusMessage.classList.remove('text-amber-400', 'text-green-500'); 
                     statusMessage.classList.add('text-red-500'); 
                     resetAnalysis(true); // Full reset on error
                     document.body.style.cursor = 'default';
                 }
                 finally { 
                     updateUIStates(); // Update UI after everything is done
                     fileInput.value = ''; 
                 }
             };
             r.onerror = (err) => { 
                 console.error("FileReader error:", err); 
                 statusMessage.textContent = "Error reading file."; 
                 statusMessage.classList.remove('text-amber-400', 'text-green-500'); 
                 statusMessage.classList.add('text-red-500'); 
                 resetAnalysis(true); 
                 updateUIStates(); 
             };
             r.readAsText(f);
        });

        toleranceSlider.addEventListener('change', () => {
            state.harkerTolerance = parseFloat(toleranceSlider.value); toleranceValue.textContent = state.harkerTolerance.toFixed(3);
            if (state.harkerAnalysisResults.length > 0) {
                 statusMessage.textContent = 'Re-combining...'; 
                 console.log(`Tol changed to ${state.harkerTolerance.toFixed(3)}. Recombining.`); 
                 // Re-combining is fast, just do it on the main thread
                 // We need to re-run *only* combineSites
                 // But combineSites is in the worker...
                 // FOR SIMPLICITY: just re-run the whole worker calc
                 runMapCalculationAndAnalysis();
            }
            else { console.log("Tol changed, no results to combine."); }
        });
        toleranceSlider.addEventListener('input', () => { toleranceValue.textContent = parseFloat(toleranceSlider.value).toFixed(3); });


        // 'input' event updates the text label continuously
        resolutionSlider.addEventListener('input', e => {
            resolutionValue.textContent = e.target.value;
        });
        
        // 'change' event (on mouse release) triggers recalculation
        resolutionSlider.addEventListener('change', e => {
            const newRes = parseInt(e.target.value);
            state.mapResolution = newRes;
            resolutionValue.textContent = newRes;
            
            if (state.crystalData) {
                console.log(`Resolution changed to ${newRes}. Recalculating...`);
                // Just run the analysis. It will set the cursor and status.
                runMapCalculationAndAnalysis();
            }
        });
        
        function setupSliceSlider(slider, valueEl, axis) {
            slider.addEventListener('input', e => { const v = parseFloat(e.target.value); state[`slice${axis.toUpperCase()}`] = v; state.activeSlicingAxis = axis; valueEl.textContent = v.toFixed(3); sliceTitle.textContent = `Slice \u22a5 ${axis.toUpperCase()} at ${v.toFixed(3)}`; drawPattersonSlice(); sliceValueU.textContent = state.sliceU.toFixed(3); sliceValueV.textContent = state.sliceV.toFixed(3); sliceValueW.textContent = state.sliceW.toFixed(3); });
             // Set initial step based on default resolution
             slider.step = Math.max(0.001, (1 / state.mapResolution)).toFixed(4);
        }
        setupSliceSlider(sliceSliderU, sliceValueU, 'u');
        setupSliceSlider(sliceSliderV, sliceValueV, 'v');
        setupSliceSlider(sliceSliderW, sliceValueW, 'w');

        pattersonCanvas.addEventListener('mousemove', e => { if(!state.pattersonMap3D) return; const r=pattersonCanvas.getBoundingClientRect(); if (r.width===0||r.height===0) return; const px=(e.clientX-r.left); const py=(e.clientY-r.top); const xf=Math.max(0,Math.min(1,px/r.width)); const yf=Math.max(0,Math.min(1,1-(py/r.height))); let u,v,w; const {sliceU,sliceV,sliceW,activeSlicingAxis,mapResolution,pattersonMap3D:map}=state; const res=mapResolution; const map_x = Math.floor(xf * (res > 0 ? res - 1 : 0)); const map_y = Math.floor(yf * (res > 0 ? res - 1 : 0)); const u_idx = Math.round(sliceU * (res > 0 ? res - 1 : 0)); const v_idx = Math.round(sliceV * (res > 0 ? res - 1 : 0)); const w_idx = Math.round(sliceW * (res > 0 ? res - 1 : 0)); let idx; if(activeSlicingAxis==='w'){u=xf;v=yf;w=sliceW; idx = w_idx*res*res + map_y*res + map_x;} else if(activeSlicingAxis==='v'){u=xf;v=sliceV;w=yf; idx = map_y*res*res + v_idx*res + map_x;} else{u=sliceU;v=xf;w=yf; idx = map_y*res*res + map_x*res + u_idx;} const mapValue = (map && idx >= 0 && idx < map.length && isFinite(map[idx])) ? map[idx] : NaN; coordsDisplay.textContent = `(u=${u.toFixed(3)}, v=${v.toFixed(3)}, w=${w.toFixed(3)}) | Val: ${isNaN(mapValue) ? 'N/A' : mapValue.toFixed(3)}`; });
        pattersonCanvas.addEventListener('mouseleave',()=>coordsDisplay.textContent='');

        let resizeTimeout; window.addEventListener('resize',()=>{ clearTimeout(resizeTimeout); resizeTimeout = setTimeout(resizeCanvas, 150); });
        const resizer=document.getElementById('drag-handle'); const cp = document.getElementById('controls-panel'); resizer.addEventListener('mousedown',e=>{ e.preventDefault(); document.body.classList.add('resizing'); const sx = e.clientX; const sw = cp.offsetWidth; const minW=400; const maxW=Math.min(800, window.innerWidth-200); const move=(ev)=>{ let nw = sw+(ev.clientX-sx); nw=Math.max(minW,Math.min(nw,maxW)); cp.style.width=`${nw}px`; resizeCanvas(); }; const up=()=>{document.body.classList.remove('resizing'); window.removeEventListener('mousemove',move); window.removeEventListener('mouseup',up); }; window.addEventListener('mousemove',move); window.addEventListener('mouseup',up); });
        leftTabButtons.forEach(b=>b.addEventListener('click',()=>{if(!b.disabled)showLeftTab(b.dataset.tab);}));
        generateReportBtn.addEventListener('click', generatePdfReport);

         sliceTitle.textContent = `Slice \u22a5 ${state.activeSlicingAxis.toUpperCase()} at ${state[`slice${state.activeSlicingAxis.toUpperCase()}`].toFixed(3)}`; // Unicode fix
         updateUIStates();

        // --- TOOLTIP CLICK TOGGLE ---
        tooltipIcon.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevents the 'document' click from firing
            tooltipText.classList.toggle('visible');
        });

        document.addEventListener('click', (e) => {
            if (tooltipText.classList.contains('visible') && 
                !tooltipIcon.contains(e.target) && 
                !tooltipText.contains(e.target)) 
            {
                tooltipText.classList.remove('visible');
            }
        });

    });
</script>


</body>
</html>

