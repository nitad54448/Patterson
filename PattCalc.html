<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patterson Map Analysis Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; margin: 0; background-color: #f1f5f9; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        #app-container { display: flex; width: 100%; flex-grow: 1; min-height: 0; }
#controls-panel {
    width: 450px;
    min-width: 400px;
    max-width: 600px;
    flex-shrink: 0;
    padding: 24px;
    background-color: #111827;
    border-right: 1px solid #374151;
    overflow-y: auto;
    color: #d1d5db;
    display: flex;
    flex-direction: column;
    position: relative; 
    z-index: 20;       
}
        #drag-handle { width: 6px; cursor: col-resize; background-color: #374151; flex-shrink: 0; transition: background-color 0.2s; }
        #drag-handle:hover { background-color: #3b82f6; }
        #results-area { flex-grow: 1; background-color: #f1f5f9; min-width: 0; padding: 1.5rem; color: #1f2937; overflow-y: auto; }

        .control-group { margin-bottom: 1.5rem; padding-bottom: 1.5rem; border-bottom: 1px solid #374151;}
        .control-group:last-of-type { border-bottom: none; padding-bottom: 0; margin-bottom: 0;}
        .control-label { display: block; margin-bottom: 8px; font-weight: 500; color: #9ca3af; }
        
        .btn { display: inline-block; padding: 0.6rem 1rem; border-radius: 0.375rem; font-weight: 600; transition: background-color 0.2s; cursor: pointer; text-align: center; width: auto; }
        .btn-full { width: 100%; }
        .btn-primary { background-color: #3b82f6; color: white; }
        .btn-primary:hover { background-color: #2563eb; }
        .btn:disabled { background-color: #4b5563; color: #9ca3af; cursor: not-allowed; }

        .info-box { background-color: #1f2937; padding: 12px; border-radius: 8px; font-family: monospace; font-size: 0.8rem; line-height: 1.6; }
        .canvas-wrapper { background-color: #1e2937; box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.2); width: 100%; overflow: hidden; aspect-ratio: 1 / 1; border-radius: 8px; }
        canvas { display: block; width: 100%; height: 100%; }
        
        /* Styled Tables */
        .styled-table { width: 100%; font-size: 0.8rem; border-collapse: collapse; }
        .styled-table th, .styled-table td { text-align: left; padding: 8px 10px; font-family: monospace; color: #374151; }
        .styled-table thead th { color: #4b5563; border-bottom: 2px solid #d1d5db; }
        .styled-table tbody tr { border-bottom: 1px solid #e5e7eb; }
        .styled-table tbody tr:nth-of-type(even) { background-color: #f9fafb; }
        .styled-table tbody tr:hover { background-color: #eff6ff; }
        .table-container { flex-grow: 1; overflow-y: auto; background-color: #f8fafc; border: 1px solid #e2e8f0; border-radius: 0.5rem; box-shadow: inset 0 1px 2px rgba(0,0,0,0.05); }
        
        .dark-table { width: 100%; }
        .dark-table th, .dark-table td { text-align: left; padding: 4px 8px; border-bottom: 1px solid #374151; font-family: monospace;}
        .dark-table th { color: #9ca3af; }
        .dark-table tbody tr:hover { background-color: #374151; }
        .dark-table-container { flex-grow: 1; overflow-y: auto; background-color: #111827; border: 1px solid #374151; border-radius: 0.5rem; box-shadow: inset 0 1px 2px rgba(0,0,0,0.05); }


        body.resizing { cursor: col-resize !important; user-select: none; }

        /* Left Panel Tabs */
        .left-tabs { display: flex; border-bottom: 1px solid #374151; margin-bottom: 1.5rem; }
        .left-tab-button {
            padding: 0.5rem 1rem; font-weight: 600; color: #9ca3af; background-color: transparent;
            border: none; border-bottom: 2px solid transparent; cursor: pointer; transition: all 0.2s;
        }
        .left-tab-button:hover:not(.left-tab-active):not(:disabled) { color: #d1d5db; border-color: #4b5563; }
        .left-tab-button.left-tab-active { color: #3b82f6; border-color: #3b82f6; }
        .left-tab-button:disabled { color: #4b5563; cursor: not-allowed; }
        .left-tab-content { display: none; flex-grow: 1; flex-direction: column;}
        .left-tab-content.active { display: flex; }
        
        /* Tooltip (opens down) */
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: pointer;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 280px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px 12px;
            position: absolute;
            z-index: 100;
            top: 150%;
            left: 50%;
            margin-left: -250px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.85rem;
            line-height: 1.4;
        }
        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            bottom: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: transparent transparent #333 transparent;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        


    </style>
</head>
<body>
    <div id="app-container">
        <div id="controls-panel">
            <div class="control-group flex justify-between items-center">
                <button id="open-file-btn" class="btn btn-primary w-11/12 mr-2">Select Data File</button>
                <div class="tooltip w-1/12 text-center text-gray-400">
                    <span class="text-xl font-bold">?</span>
                    <span class="tooltiptext">Load a Pawley refinement output file (.dat), like those generated by Powder5, containing cell parameters, space group, and reflection intensities.</span>
                </div>
                <input type="file" id="data-file-input" class="hidden"/>
            </div>
            <div id="status-message" class="text-sm text-amber-400 -mt-4 mb-4 h-4"></div>

            <div class="flex-grow flex flex-col">
                <div class="left-tabs">
                    <button class="left-tab-button left-tab-active" data-tab="map-controls-tab">Map</button>
                    <button class="left-tab-button" data-tab="slices-controls-tab" disabled>Slices</button>
                    <button class="left-tab-button" data-tab="peaks-controls-tab" disabled>Peaks</button>
                </div>
                
                <div id="map-controls-tab" class="left-tab-content active">
                    <div class="control-group">
                        <label class="control-label">Crystal & Refinement Data</label>
                        <div id="crystal-info-box" class="info-box min-h-[120px]">Upload a file to see data.</div>
                    </div>
                    <div class="control-group">
                        <label class="control-label">Patterson Map Calculation</label>
                        <div>
                            <label for="resolution-slider" class="block mb-2 text-sm font-medium">Map Resolution: <span id="resolution-value" class="font-bold">50</span></label>
                            <input type="range" id="resolution-slider" min="20" max="100" value="50" step="5" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer" disabled>
                        </div>
                        <button id="calculate-btn" class="btn btn-primary btn-full mt-4" disabled>Calculate 3D Map & Analyze</button>
                    </div>
                </div>

                <div id="slices-controls-tab" class="left-tab-content">
                     <div class="control-group">
                        <label class="control-label">Slice Controls</label>
                        <div class="space-y-4">
                            <div>
                                <label for="slice-slider-u" class="block mb-2 text-sm font-medium">Slice Position U: <span id="slice-value-u" class="font-bold">0.500</span></label>
                                <input type="range" id="slice-slider-u" min="0" max="1" value="0.5" step="0.02" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer" disabled>
                            </div>
                            <div>
                                <label for="slice-slider-v" class="block mb-2 text-sm font-medium">Slice Position V: <span id="slice-value-v" class="font-bold">0.500</span></label>
                                <input type="range" id="slice-slider-v" min="0" max="1" value="0.5" step="0.02" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer" disabled>
                            </div>
                            <div>
                                <label for="slice-slider-w" class="block mb-2 text-sm font-medium">Slice Position W: <span id="slice-value-w" class="font-bold">0.500</span></label>
                                <input type="range" id="slice-slider-w" min="0" max="1" value="0.5" step="0.02" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer" disabled>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="peaks-controls-tab" class="left-tab-content flex-grow flex flex-col">
                    <div class="control-group">
                        <label class="control-label">Peak Analysis</label>
                        <div>
                            <label for="tolerance-slider" class="block mb-2 text-sm font-medium">Combination Tolerance: <span id="tolerance-value" class="font-bold">0.030</span></label>
                            <input type="range" id="tolerance-slider" min="0.01" max="0.10" value="0.03" step="0.005" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer" disabled>
                        </div>
                    </div>
                     <div class="control-group flex-grow flex flex-col">
                        <h3 class="font-semibold text-gray-300 mb-2">Proposed Heavy Atom Sites (Partial)</h3>
                        <div id="sites-table-container" class="dark-table-container flex-grow">
                            <table class="w-full dark-table">
                                <thead class="sticky top-0 bg-gray-800"><tr><th>Source</th><th>(x, y, z)</th></tr></thead>
                                <tbody id="sites-table-body"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
            
            <button id="generate-report-btn" class="btn btn-primary btn-full mt-auto" disabled>Generate PDF Report</button>
        </div>

        <div id="drag-handle"></div>

        <div id="results-area" class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
                 <h2 id="slice-title" class="text-lg font-semibold text-center mb-3">Patterson Map Slice</h2>
                 <div class="canvas-wrapper"><canvas id="patterson-canvas"></canvas></div>
                 <div id="coords-display" class="font-mono text-sm text-center mt-2 h-5 text-slate-600"></div>
            </div>
            <div class="flex flex-col min-h-0 gap-6">
                 <div class="flex flex-col flex-1">
                    <h2 class="text-lg font-semibold text-center mb-3 flex-shrink-0">Found Patterson Peaks</h2>
                    <div class="table-container max-h-full">
                        <table id="peaks-table" class="styled-table">
                            <thead><tr><th>Height</th><th>(u, v, w)</th></tr></thead>
                            <tbody id="peaks-table-body"></tbody>
                        </table>
                    </div>
                 </div>
                 <div class="flex flex-col flex-1">
                    <h2 class="text-lg font-semibold text-center mb-3 flex-shrink-0">Consolidated Heavy Atom Sites</h2>
                    <div class="table-container max-h-full">
                        <table id="consolidated-sites-table" class="styled-table">
                            <thead><tr><th>(x, y, z)</th></tr></thead>
                            <tbody id="consolidated-sites-table-body"></tbody>
                        </table>
                    </div>
                 </div>
            </div>
        </div>
    </div>
    
    <footer class="fixed bottom-0 right-0 p-2 text-xs text-slate-400">PattersonCalc v1.0</footer>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM ELEMENTS ---
        const openFileBtn = document.getElementById('open-file-btn');
        const fileInput = document.getElementById('data-file-input');
        const statusMessage = document.getElementById('status-message');
        const crystalInfoBox = document.getElementById('crystal-info-box');
        const calculateBtn = document.getElementById('calculate-btn');
        const resolutionSlider = document.getElementById('resolution-slider');
        const resolutionValue = document.getElementById('resolution-value');
        const sliceSliderU = document.getElementById('slice-slider-u'), sliceValueU = document.getElementById('slice-value-u');
        const sliceSliderV = document.getElementById('slice-slider-v'), sliceValueV = document.getElementById('slice-value-v');
        const sliceSliderW = document.getElementById('slice-slider-w'), sliceValueW = document.getElementById('slice-value-w');
        const sliceTitle = document.getElementById('slice-title');
        const toleranceSlider = document.getElementById('tolerance-slider');
        const toleranceValue = document.getElementById('tolerance-value');
        const peaksTableBody = document.getElementById('peaks-table-body');
        const sitesTableBody = document.getElementById('sites-table-body');
        const consolidatedSitesTableBody = document.getElementById('consolidated-sites-table-body');
        const pattersonCanvas = document.getElementById('patterson-canvas');
        const coordsDisplay = document.getElementById('coords-display');
        const pattersonCtx = pattersonCanvas.getContext('2d');
        const generateReportBtn = document.getElementById('generate-report-btn');
        const leftTabButtons = document.querySelectorAll('.left-tab-button');
        const leftTabContents = document.querySelectorAll('.left-tab-content');

        // --- STATE ---
        let state = {
            crystalData: null, spaceGroups: null, pattersonMap3D: null, fileName: null,
            mapResolution: 50, harkerTolerance: 0.03,
            foundPeaks: [], harkerAnalysisResults: [], consolidatedSites: [],
            sliceU: 0.5, sliceV: 0.5, sliceW: 0.5,
            activeSlicingAxis: 'w',
        };

        // --- INITIALIZATION ---
        fetch('space_groups_harker.json')
            .then(response => {
                if (!response.ok) throw new Error("Could not load space_groups_harker.json");
                return response.json();
            })
            .then(data => {
                state.spaceGroups = data;
                console.log("Harker data for all space groups loaded successfully.");
            })
            .catch(error => {
                statusMessage.textContent = `Error: ${error.message}`;
                statusMessage.classList.remove('text-amber-400');
                statusMessage.classList.add('text-red-500');
            });

        resizeCanvas();
        updateUIStates();
        updateAllTables();

        // --- UI UTILS ---
            function updateUIStates() {
            const hasData = !!state.crystalData;
            const hasMap = !!state.pattersonMap3D;
            // This line is no longer the primary controller for the slider/tab
            const hasHarkerResults = state.harkerAnalysisResults.length > 0;

            // Main controls
            resolutionSlider.disabled = !hasData;
            calculateBtn.disabled = !hasData;
            
            // Slice controls
            [sliceSliderU, sliceSliderV, sliceSliderW].forEach(s => s.disabled = !hasMap);
            
            toleranceSlider.disabled = !hasMap; 

            // Tab buttons
            leftTabButtons.forEach(btn => {
                const tab = btn.dataset.tab;
                if (tab.includes('slices')) {
                    btn.disabled = !hasMap;
                } else if (tab.includes('peaks')) {
                    // The "Peaks" tab is now also enabled as long as a map exists.
                    btn.disabled = !hasMap; 
                }
            });


            // Report button logic remains the same, as a report is only useful with results.
            generateReportBtn.disabled = !hasHarkerResults;
        }

        function showLeftTab(tabId) {
            leftTabContents.forEach(content => content.classList.remove('active'));
            leftTabButtons.forEach(button => button.classList.remove('left-tab-active'));
            document.getElementById(tabId).classList.add('active');
            document.querySelector(`.left-tab-button[data-tab="${tabId}"]`).classList.add('left-tab-active');
        }

        // --- PARSING & CALCULATION ---
        function solveCoordinate(solverString, peak) {
            if (solverString === '?') return '?';
            try {
                const solverFunc = new Function('u', 'v', 'w', `return ${solverString}`);
                const result = solverFunc(peak.u, peak.v, peak.w);
                return (((result % 1) + 1) % 1).toFixed(3);
            } catch (e) {
                console.error(`Error solving expression: "${solverString}" for peak`, peak, e);
                return 'err';
            }
        }

        function parsePawleyFile(text) {
            const data = { cell: {}, reflections: [] };
            const cellRegex = /^\s*([a-zA-Z]+)\s*\(.*\)\s+([\d.eE+-]+)/;
            const spaceGroupRegex = /Space Group:\s+(\d+)\s*–\s*(.+)/;
            const reflectionRegex = /^\(([\s-]*\d+),([\s-]*\d+),([\s-]*\d+)\)\s+[\d.]+\s+([\d.]+)/;
            let inReflectionsSection = false;
            for (const line of text.split('\n')) {
                if (line.includes('--- Reflections List')) { inReflectionsSection = true; continue; }
                if (!inReflectionsSection) {
                    let match = line.match(cellRegex); if (match) data.cell[match[1]] = parseFloat(match[2]);
                    match = line.match(spaceGroupRegex); if (match) data.spaceGroup = { number: parseInt(match[1]), name: match[2].trim() };
                } else {
                    const match = line.match(reflectionRegex);
                    if (match) data.reflections.push({h:parseInt(match[1]),k:parseInt(match[2]),l:parseInt(match[3]),intensity:parseFloat(match[4])});
                }
            }
            if (!data.cell.alpha) data.cell.alpha = 90; if (!data.cell.beta) data.cell.beta = 90; if (!data.cell.gamma) data.cell.gamma = 90;
            return data;
        }

        async function calculatePattersonMap() {
            return new Promise(resolve => {
                statusMessage.textContent = 'Calculating 3D Patterson map...';
                setTimeout(() => {
                    const { cell, reflections } = state.crystalData, res = state.mapResolution, V = cell.a * cell.b * cell.c;
                    state.pattersonMap3D = new Float32Array(res * res * res);
                    for (let iw=0; iw<res; iw++) for (let iv=0; iv<res; iv++) for (let iu=0; iu<res; iu++) {
                        const u=iu/res, v=iv/res, w=iw/res; let p=0;
                        for (const r of reflections) p += r.intensity * Math.cos(2*Math.PI*(r.h*u + r.k*v + r.l*w));
                        state.pattersonMap3D[iw*res*res + iv*res + iu] = p/V;
                    }
                    resolve();
                }, 50);
            });
        }
        
        function findPeaks() {
            const res=state.mapResolution, map=state.pattersonMap3D; if(!map) return;
            let peaks=[], maxVal=0; for(let i=1; i<map.length; i++) if(map[i]>maxVal) maxVal=map[i];
            const threshold=maxVal*0.15;
            for(let iw=1; iw<res-1; iw++) for(let iv=1; iv<res-1; iv++) for(let iu=1; iu<res-1; iu++) {
                const idx=iw*res*res+iv*res+iu, val=map[idx]; if(val<threshold) continue;
                let isMax=true;
                for(let dw=-1; dw<=1 && isMax; dw++) for(let dv=-1; dv<=1 && isMax; dv++) for(let du=-1; du<=1 && isMax; du++) {
                    if(du===0 && dv===0 && dw===0) continue;
                    if(map[(iw+dw)*res*res+(iv+dv)*res+(iu+du)] >= val) isMax=false;
                }
                if(isMax) peaks.push({u:iu/res, v:iv/res, w:iw/res, height:val/maxVal});
            }
            peaks.sort((a,b)=>b.height-a.height); state.foundPeaks=peaks.slice(0,50);
        }

        function analyzeHarkerPeaks() {
            state.harkerAnalysisResults = [];
            if (!state.crystalData || state.foundPeaks.length === 0 || !state.spaceGroups) return;
            const sgNumber = state.crystalData.spaceGroup.number, sgData = state.spaceGroups[sgNumber], tol = 0.03;
            if (!sgData || !sgData.harker_sections) {
                statusMessage.textContent = `Harker data for SG ${sgNumber} not found in JSON.`;
                return;
            }
            if (sgData.harker_sections.length === 0) {
                statusMessage.textContent = `No Harker sections defined for SG ${sgNumber}.`;
                return;
            }
            sgData.harker_sections.forEach(section => {
                state.foundPeaks.forEach(peak => {
                    if (Math.abs(peak[section.coordinate] - section.value) < tol) {
                        state.harkerAnalysisResults.push({
                            source: `${section.type.charAt(0).toUpperCase() + section.type.slice(1)} (${section.coordinate}=${section.value})`,
                            x: solveCoordinate(section.solver.x, peak),
                            y: solveCoordinate(section.solver.y, peak),
                            z: solveCoordinate(section.solver.z, peak)
                        });
                    }
                });
            });
            if (state.harkerAnalysisResults.length > 0) {
                statusMessage.textContent = `Harker analysis found ${state.harkerAnalysisResults.length} partial sites.`;
            } else {
                statusMessage.textContent = `Analysis complete, but no matching Harker peaks were found for SG ${sgNumber}.`;
            }
        }
        
        function combineSites() {
            state.consolidatedSites = [];
            const results = state.harkerAnalysisResults;
            const tol = state.harkerTolerance;
            if (!results || results.length < 2) {
                statusMessage.textContent = `Sites re-combined. Found 0 unique site(s).`;
                return;
            }
            const areClose = (c1, c2) => {
                if (c1 === '?' || c2 === '?') return false;
                const v1 = parseFloat(c1), v2 = parseFloat(c2);
                if (isNaN(v1) || isNaN(v2)) return false;
                return Math.min(Math.abs(v1 - v2), 1 - Math.abs(v1 - v2)) < tol;
            };
            const isNum = (c) => c !== '?' && !isNaN(parseFloat(c));
            const potentialSites = [];
            for (let i = 0; i < results.length; i++) for (let j = i + 1; j < results.length; j++) {
                const r1 = results[i], r2 = results[j];
                if (isNum(r1.x) && isNum(r2.y) && areClose(r1.z, r2.z)) potentialSites.push({ x: parseFloat(r1.x), y: parseFloat(r2.y), z: (parseFloat(r1.z) + parseFloat(r2.z)) / 2 });
                if (isNum(r2.x) && isNum(r1.y) && areClose(r1.z, r2.z)) potentialSites.push({ x: parseFloat(r2.x), y: parseFloat(r1.y), z: (parseFloat(r1.z) + parseFloat(r2.z)) / 2 });
                if (isNum(r1.x) && isNum(r2.z) && areClose(r1.y, r2.y)) potentialSites.push({ x: parseFloat(r1.x), y: (parseFloat(r1.y) + parseFloat(r2.y)) / 2, z: parseFloat(r2.z) });
                if (isNum(r2.x) && isNum(r1.z) && areClose(r1.y, r2.y)) potentialSites.push({ x: parseFloat(r2.x), y: (parseFloat(r1.y) + parseFloat(r2.y)) / 2, z: parseFloat(r1.z) });
                if (isNum(r1.y) && isNum(r2.z) && areClose(r1.x, r2.x)) potentialSites.push({ x: (parseFloat(r1.x) + parseFloat(r2.x)) / 2, y: parseFloat(r1.y), z: parseFloat(r2.z) });
                if (isNum(r2.y) && isNum(r1.z) && areClose(r1.x, r2.x)) potentialSites.push({ x: (parseFloat(r1.x) + parseFloat(r2.x)) / 2, y: parseFloat(r2.y), z: parseFloat(r1.z) });
            }
            if (potentialSites.length === 0) {
                statusMessage.textContent = `Sites re-combined. Found 0 unique site(s).`;
                return;
            }
            const finalSites = [];
            let unassignedSites = [...potentialSites];
            while (unassignedSites.length > 0) {
                let currentGroup = [unassignedSites.shift()], sitesToRecheck = [];
                for (const site of unassignedSites) {
                    if (currentGroup.some(member => areClose(site.x, member.x) && areClose(site.y, member.y) && areClose(site.z, member.z))) {
                        currentGroup.push(site);
                    } else { sitesToRecheck.push(site); }
                }
                unassignedSites = sitesToRecheck;
                const sum = currentGroup.reduce((a, s) => ({ x: a.x + s.x, y: a.y + s.y, z: a.z + s.z }), { x: 0, y: 0, z: 0 });
                const norm = val => (((val % 1) + 1) % 1);
                finalSites.push({ x: norm(sum.x/currentGroup.length), y: norm(sum.y/currentGroup.length), z: norm(sum.z/currentGroup.length) });
            }
            state.consolidatedSites = finalSites;
            statusMessage.textContent = `Sites re-combined. Found ${finalSites.length} unique site(s).`;
        }

        // --- UI & DRAWING ---
        function updateCrystalInfo() {
            if (!state.crystalData) { crystalInfoBox.innerHTML = 'Upload a file to see data.'; return; }
            const { cell, spaceGroup, reflections } = state.crystalData; 
            crystalInfoBox.innerHTML = `<strong>Space Group:</strong> ${spaceGroup.number} (${spaceGroup.name})<br>
            <strong>Cell:</strong> a=${cell.a.toFixed(4)}, b=${cell.b.toFixed(4)}, c=${cell.c.toFixed(4)}<br>
            <strong>Angles:</strong> α=${cell.alpha.toFixed(1)}°, β=${cell.beta.toFixed(1)}°, γ=${cell.gamma.toFixed(1)}°<br>
            <strong>Reflections:</strong> ${reflections.length}`;
        }
        
        function drawPattersonSlice() {
            if (!state.pattersonMap3D) { pattersonCtx.fillStyle='#1e2937'; pattersonCtx.fillRect(0,0,pattersonCanvas.width,pattersonCanvas.height); return; }
            const res=state.mapResolution, map=state.pattersonMap3D, axis=state.activeSlicingAxis;
            const u_idx=Math.round(state.sliceU*(res-1)),v_idx=Math.round(state.sliceV*(res-1)),w_idx=Math.round(state.sliceW*(res-1));
            let min=Infinity, max=-Infinity;
            for(let i=0; i<res; i++) for(let j=0; j<res; j++) {
                let idx = axis==='u' ? j*res*res+i*res+u_idx : (axis==='v' ? j*res*res+v_idx*res+i : w_idx*res*res+j*res+i);
                if(map[idx]<min) min=map[idx]; if(map[idx]>max) max=map[idx];
            }
            const size=pattersonCanvas.width, img=pattersonCtx.createImageData(size,size), data=img.data;
            for(let py=0; py<size; py++) for(let px=0; px<size; px++) {
                const iu=Math.floor(px/size*res), iv=Math.floor((1-py/size)*res);
                let idx = axis==='u' ? iv*res*res+iu*res+u_idx : (axis==='v' ? iv*res*res+v_idx*res+iu : w_idx*res*res+iv*res+iu);
                const val = max>min ? (map[idx]-min)/(max-min) : 0;
                let r=0, g=0, b=0;
                if(val<0.25) b=4*val; else if(val<0.75){r=Math.sin((val-0.25)*Math.PI);b=Math.cos((val-0.25)*Math.PI);}else{r=1;g=2*(val-0.75);}
                const d_idx=(py*size+px)*4; data[d_idx]=r*255; data[d_idx+1]=g*255; data[d_idx+2]=b*255; data[d_idx+3]=255;
            }
            pattersonCtx.putImageData(img,0,0);
        }

        function updateAllTables() {
            peaksTableBody.innerHTML = state.foundPeaks.length === 0 ? '<tr><td colspan="2" class="text-center text-gray-500 py-8">No peaks found.</td></tr>' : state.foundPeaks.map(p => `<tr><td>${p.height.toFixed(2)}</td><td>(${p.u.toFixed(3)}, ${p.v.toFixed(3)}, ${p.w.toFixed(3)})</td></tr>`).join('');
            sitesTableBody.innerHTML = state.harkerAnalysisResults.length === 0 ? '<tr><td colspan="2" class="text-center text-gray-500 py-4">No analysis performed.</td></tr>' : state.harkerAnalysisResults.map(s => `<tr><td>${s.source}</td><td>(${s.x}, ${s.y}, ${s.z})</td></tr>`).join('');
            consolidatedSitesTableBody.innerHTML = state.consolidatedSites.length === 0 ? '<tr><td class="text-center text-gray-500 py-8">No sites combined.</td></tr>' : state.consolidatedSites.map(s => `<tr><td>(${s.x.toFixed(3)}, ${s.y.toFixed(3)}, ${s.z.toFixed(3)})</td></tr>`).join('');
        }

        function resizeCanvas() { const size=pattersonCanvas.parentElement.clientWidth; pattersonCanvas.width=size; pattersonCanvas.height=size; drawPattersonSlice(); }
        
        function resetAnalysis(isNewFile = false) { 
            if(isNewFile) {
                state.crystalData = null;
                updateCrystalInfo();
            }
            state.pattersonMap3D=null; state.foundPeaks=[]; state.harkerAnalysisResults=[]; state.consolidatedSites=[]; 
            updateAllTables(); drawPattersonSlice(); updateUIStates(); showLeftTab('map-controls-tab'); 
            statusMessage.textContent = isNewFile ? '' : statusMessage.textContent; 
        }

        async function generatePdfReport() {
            if(!state.crystalData || state.harkerAnalysisResults.length===0) return;
            const { jsPDF } = window.jspdf; const doc = new jsPDF(); let y=15; const m=10, lh=6;
            doc.setFontSize(18); doc.text("Patterson Analysis Report", m, y); y+=lh*2;
            const now = new Date();
            const timestamp = `${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}_${String(now.getHours()).padStart(2,'0')}${String(now.getMinutes()).padStart(2,'0')}${String(now.getSeconds()).padStart(2,'0')}`;
            doc.setFontSize(10); doc.text(`Date: ${now.toLocaleString()} | File: ${state.fileName||'N/A'}`, m, y); y+=lh*2;
            const {cell,spaceGroup,reflections}=state.crystalData; 
            doc.autoTable({ startY: y, head: [['Parameter', 'Value']], body: [ ['Space Group', `${spaceGroup.number} (${spaceGroup.name})`], ['Cell a, b, c', `${cell.a.toFixed(4)}, ${cell.b.toFixed(4)}, ${cell.c.toFixed(4)}`], ['Cell α, β, γ', `${cell.alpha.toFixed(1)}, ${cell.beta.toFixed(1)}, ${cell.gamma.toFixed(1)}`], ['Reflections', reflections.length] ], theme: 'striped', headStyles: { fillColor: [75, 85, 99] } }); y=doc.autoTable.previous.finalY+lh*2;
            doc.setFontSize(12); doc.text("Active Patterson Map Slice", m, y); y+=lh;
            const canvas=pattersonCanvas, imgData=canvas.toDataURL('image/png'), imgW=90, imgH=(canvas.height*imgW)/canvas.width;
            if(y+imgH>doc.internal.pageSize.height){doc.addPage(); y=m;} doc.addImage(imgData,'PNG',m,y,imgW,imgH); y+=imgH+lh;
            doc.setFontSize(10); doc.text(`Slice: Plane normal to ${state.activeSlicingAxis.toUpperCase()} at ${state[`slice${state.activeSlicingAxis.toUpperCase()}`].toFixed(3)}`,m,y); doc.addPage(); y=15;
            
            doc.autoTable({html: '#peaks-table', startY: y, theme: 'striped', headStyles: { fillColor: [75, 85, 99] }, didDrawPage: data => y = data.cursor.y + lh*2, tableWidth: 'auto', styles: { cellPadding: 2, fontSize: 8 } }); y=doc.autoTable.previous.finalY+lh*2;
            if(state.consolidatedSites.length>0) doc.autoTable({html: '#consolidated-sites-table', startY: y, theme: 'striped', headStyles: { fillColor: [22, 163, 74] }, tableWidth: 'auto', styles: { cellPadding: 2, fontSize: 8 } });
            
            doc.save(`Patterson_Report_${timestamp}.pdf`);
        }
        
        // --- NEW ANALYSIS FUNCTION ---
        async function runFullAnalysis() {
            if (!state.crystalData) return;

            // 1. Disable controls and provide user feedback
            calculateBtn.disabled = true;
            resolutionSlider.disabled = true;
            statusMessage.textContent = 'Calculating 3D Patterson map...';

            // 2. Run the full analysis pipeline
            await calculatePattersonMap();
            findPeaks();
            analyzeHarkerPeaks();
            combineSites();
            updateAllTables();
            
            // 3. Re-enable controls based on the new state
            updateUIStates(); 
            drawPattersonSlice(); 
            
            // 4. Intelligently switch to the slices tab only on the first run
            const mapTab = document.getElementById('map-controls-tab');
            if (mapTab.classList.contains('active')) {
                showLeftTab('slices-controls-tab');
            }
        }

        // --- EVENT HANDLERS ---
        openFileBtn.addEventListener('click',()=>fileInput.click());
        fileInput.addEventListener('change',e=>{ const f=e.target.files[0]; if(!f) return; state.fileName=f.name; const r=new FileReader(); r.onload=ev=>{ try{state.crystalData=parsePawleyFile(ev.target.result); if(!state.crystalData.cell.a)throw new Error("File invalid."); statusMessage.textContent=`${f.name} loaded.`; updateCrystalInfo(); resetAnalysis(); updateUIStates();}catch(err){statusMessage.textContent=`Error: ${err.message}`; resetAnalysis(true);}}; r.readAsText(f); });

        // Calculate button now calls the main analysis function
        calculateBtn.addEventListener('click', runFullAnalysis);
        
        toleranceSlider.addEventListener('input', e => {
            state.harkerTolerance = parseFloat(e.target.value);
            toleranceValue.textContent = state.harkerTolerance.toFixed(3);
            statusMessage.textContent = 'Recalculating with new tolerance...';
            setTimeout(() => {
                combineSites();
                updateAllTables();
            }, 10);
        });

        // Resolution slider now has two event listeners
        resolutionSlider.addEventListener('input', e => {
            // Updates the displayed value as you drag
            state.mapResolution = parseInt(e.target.value);
            resolutionValue.textContent = state.mapResolution;
        });

        resolutionSlider.addEventListener('change', () => {
            // Triggers a full recalculation when you release the slider
            if (state.pattersonMap3D) {
                const step = 1 / state.mapResolution;
                [sliceSliderU, sliceSliderV, sliceSliderW].forEach(s => s.step = step.toFixed(4));
                runFullAnalysis();
            }
        });
        
        function setupSliceSlider(slider, valueEl, axis) {
            slider.addEventListener('input', e => {
                const value = parseFloat(e.target.value);
                state[`slice${axis.toUpperCase()}`] = value;
                state.activeSlicingAxis = axis;
                valueEl.textContent = value.toFixed(3);
                sliceTitle.textContent = `Patterson Map Slice (Plane ⊥ to ${axis.toUpperCase()} at ${value.toFixed(3)})`;
                drawPattersonSlice();
            });
        }
        setupSliceSlider(sliceSliderU, sliceValueU, 'u');
        setupSliceSlider(sliceSliderV, sliceValueV, 'v');
        setupSliceSlider(sliceSliderW, sliceValueW, 'w');
        
        pattersonCanvas.addEventListener('mousemove', e => { if(!state.pattersonMap3D) return; const rect=pattersonCanvas.getBoundingClientRect(),x=(e.clientX-rect.left)/rect.width,y=1-((e.clientY-rect.top)/rect.height); let txt=''; const {sliceU,sliceV,sliceW,activeSlicingAxis}=state; if(activeSlicingAxis==='w')txt=`(u=${x.toFixed(3)}, v=${y.toFixed(3)}, w=${sliceW.toFixed(3)})`; else if(activeSlicingAxis==='v')txt=`(u=${x.toFixed(3)}, v=${sliceV.toFixed(3)}, w=${y.toFixed(3)})`; else txt=`(u=${sliceU.toFixed(3)}, v=${x.toFixed(3)}, w=${y.toFixed(3)})`; coordsDisplay.textContent=txt; });
        pattersonCanvas.addEventListener('mouseleave',()=>coordsDisplay.textContent='');
        window.addEventListener('resize',()=>setTimeout(resizeCanvas,50));
        
        const resizer=document.getElementById('drag-handle'); resizer.addEventListener('mousedown',e=>{ e.preventDefault(); document.body.classList.add('resizing'); const move=(ev)=>{if(ev.clientX>=400 && ev.clientX<=600) document.getElementById('controls-panel').style.width=`${ev.clientX}px`;}; const up=()=>{document.body.classList.remove('resizing'); window.removeEventListener('mousemove',move); window.removeEventListener('mouseup',up); setTimeout(resizeCanvas,50);}; window.addEventListener('mousemove',move); window.addEventListener('mouseup',up); });
        leftTabButtons.forEach(b=>b.addEventListener('click',()=>{if(!b.disabled)showLeftTab(b.dataset.tab);}));
        generateReportBtn.addEventListener('click', generatePdfReport);
    });
</script>


</body>
</html>