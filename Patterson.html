<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patterson Simulator</title>
     <link href="./dist/output.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; margin: 0; background-color: #f1f5f9; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        #app-container { display: flex; width: 100%; flex-grow: 1; min-height: 0; }
        #controls-panel { width: 400px; min-width: 350px; max-width: 550px; flex-shrink: 0; padding: 24px; background-color: #111827; border-right: 1px solid #374151; overflow-y: auto; color: #d1d5db; }
        #drag-handle { width: 6px; cursor: col-resize; background-color: #374151; flex-shrink: 0; transition: background-color 0.2s; }
        #drag-handle:hover { background-color: #3b82f6; }
        #results-area { flex-grow: 1; background-color: #f1f5f9; min-width: 0; display: flex; flex-direction: column; padding: 1.5rem; color: #1f2937; overflow-y: auto; }
        
        .control-group { margin-bottom: 1.5rem; padding-bottom: 1.5rem; border-bottom: 1px solid #374151;}
        .control-group:last-child { border-bottom: none; padding-bottom: 0; }
        .control-label { display: block; margin-bottom: 8px; font-weight: 500; color: #9ca3af; }
        
        input[type="radio"]:checked + label { background-color: #3b82f6; color: white; border-color: #2563eb; }
        .atom-type-label { text-align: center; padding: 0.5rem; border: 1px solid #4b5563; background-color: #374151; color: #e5e7eb; border-radius: 0.375rem; cursor: pointer; transition: all 0.2s ease; }
        .atom-type-label:hover { background-color: #4b5563; }
        
        .btn-danger { display: block; padding: 0.5rem 1rem; border-radius: 0.375rem; font-weight: 600; transition: background-color 0.2s; cursor: pointer; text-align: center; background-color: #dc2626; color: white; width: 100%;}
        .btn-danger:hover { background-color: #b91c1c; }

        footer { width: 100%; background-color: #ffffff; padding: 8px 24px; font-size: 0.8em; color: #4b5563; border-top: 1px solid #e5e7eb; flex-shrink: 0; }
        
        .canvas-wrapper { background-color: #e5e7eb; box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.05); width: 100%; overflow: hidden; aspect-ratio: 1 / 1; }
        canvas { cursor: crosshair; display: block; width: 100%; height: 100%; }
        
        .coord-input { width: 60px; text-align: center; background-color: #374151; border: 1px solid #4b5563; color: #e5e7eb; border-radius: 0.375rem; padding: 2px 4px; }
        .coord-input:focus { outline: none; border-color: #3b82f6; }
        
        .plot-grid { display: grid; grid-template-areas: 'y-axis plot' '. x-axis'; grid-template-rows: 1fr auto; grid-template-columns: auto 1fr; gap: 0.25rem; }
        .y-axis-labels { grid-area: y-axis; }
        .x-axis-labels { grid-area: x-axis; }
        .plot-area { grid-area: plot; }

        .toggle-checkbox:checked { right: 0; border-color: #3b82f6; }
        .toggle-checkbox:checked + .toggle-label { background-color: #3b82f6; }
        body.resizing { cursor: col-resize !important; user-select: none; }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="controls-panel">
            <h1 class="text-2xl font-bold text-white mb-4">Patterson Simulator</h1>
            
            <div class="control-group">
                <label class="control-label">Instructions</label>
                <p class="text-sm text-gray-400">
                    1. Select atom type & click on the canvas to add.<br>
                    2. Adjust scattering factors with the sliders.<br>
                    3. Hover over Patterson peaks to see vectors.
                </p>
            </div>
            
            <div class="control-group">
                <label class="control-label">Select Atom Type to Add</label>
                <div id="atom-type-selector" class="grid grid-cols-2 gap-2">
                    <input type="radio" id="atom-type-a" name="atom-type" value="A" class="sr-only" checked>
                    <label for="atom-type-a" class="atom-type-label">Type A</label>
                    <input type="radio" id="atom-type-b" name="atom-type" value="B" class="sr-only">
                    <label for="atom-type-b" class="atom-type-label">Type B</label>
                </div>
            </div>
            
            <div class="control-group">
                <label class="control-label">Scattering Factors</label>
                <div class="space-y-4">
                     <div>
                        <label for="fa-slider" class="block mb-2 text-sm font-medium">Atom A (f<sub>A</sub>): <span id="fa-value" class="font-bold">6</span></label>
                        <input type="range" id="fa-slider" min="1" max="80" value="6" step="1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div>
                        <label for="fb-slider" class="block mb-2 text-sm font-medium">Atom B (f<sub>B</sub>): <span id="fb-value" class="font-bold">29</span></label>
                        <input type="range" id="fb-slider" min="1" max="80" value="29" step="1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                </div>
            </div>

            <div class="control-group">
                <label class="control-label">Diffraction Controls</label>
                 <div class="space-y-4">
                     <div>
                        <label for="hk-range-slider" class="block mb-2 text-sm font-medium">Range (h,k): <span id="hk-range-value" class="font-bold">10</span></label>
                        <input type="range" id="hk-range-slider" min="3" max="20" value="10" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div>
                        <label for="spot-size-slider" class="block mb-2 text-sm font-medium">Spot Size Multiplier: <span id="spot-size-value" class="font-bold">5</span></label>
                        <input type="range" id="spot-size-slider" min="1" max="15" value="5" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="toggle-hk-labels" class="text-sm font-medium">Show h,k Labels</label>
                        <div class="relative inline-block w-10 mr-2 align-middle select-none">
                            <input type="checkbox" name="toggle" id="toggle-hk-labels" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                            <label for="toggle-hk-labels" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-600 cursor-pointer"></label>
                        </div>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <label class="control-label">Vector Details</label>
                <div id="vector-info-box" class="bg-gray-900/50 p-3 rounded-lg border border-gray-700 min-h-[100px] text-sm font-mono">
                    Hover over a Patterson peak...
                </div>
            </div>

            <div class="control-group">
                 <label class="control-label">Atom List</label>
                <div id="atom-list-container" class="max-h-72 overflow-y-auto bg-gray-900/50 p-2 rounded-lg border border-gray-700">
                    <ul id="atom-list" class="space-y-2">
                        <li id="no-atoms-msg" class="text-gray-500 text-sm text-center p-2">No atoms added yet.</li>
                    </ul>
                </div>
                <button id="clear-btn" class="btn-danger mt-4">Clear All Atoms</button>
            </div>
        </div>

        <div id="drag-handle"></div>

        <div id="results-area">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="bg-white p-4 shadow-md rounded-lg">
                    <h2 class="text-lg font-semibold text-center mb-3">Crystal Structure (Real Space)</h2>
                    <div class="plot-grid">
                        <div id="real-y-axis" class="y-axis-labels"></div>
                        <div id="real-x-axis" class="x-axis-labels"></div>
                        <div class="plot-area canvas-wrapper"><canvas id="real-space-canvas"></canvas></div>
                    </div>
                </div>

                <div class="bg-white p-4 shadow-md rounded-lg">
                    <h2 class="text-lg font-semibold text-center mb-3">Patterson Map (Vector Space)</h2>
                    <div class="plot-grid">
                        <div id="patterson-y-axis" class="y-axis-labels"></div>
                        <div id="patterson-x-axis" class="x-axis-labels"></div>
                        <div class="plot-area canvas-wrapper"><canvas id="patterson-canvas"></canvas></div>
                    </div>
                </div>
                
                <div class="bg-white p-4 shadow-md rounded-lg">
                    <h2 class="text-lg font-semibold text-center mb-3">Diffraction Pattern (|F<sub>hkl</sub>|²)</h2>
                    <div class="plot-grid">
                        <div id="diffraction-y-axis" class="y-axis-labels"></div>
                        <div id="diffraction-x-axis" class="x-axis-labels"></div>
                        <div class="plot-area canvas-wrapper"><canvas id="diffraction-canvas"></canvas></div>
                    </div>
                </div>

                <div class="bg-white p-4 shadow-md rounded-lg">
                    <h2 class="text-lg font-semibold text-center mb-3">FT of Intensities (Patterson)</h2>
                    <div class="plot-grid">
                        <div id="ft-y-axis" class="y-axis-labels"></div>
                        <div id="ft-x-axis" class="x-axis-labels"></div>
                        <div class="plot-area canvas-wrapper"><canvas id="ft-canvas"></canvas></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <footer>
        2D crystal structures, diffraction patterns and Patterson functions. (NitaD, Univ. Paris-Saclay, ver 11 oct 2025)
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM ELEMENT SELECTION ---
            const realCanvas = document.getElementById('real-space-canvas');
            const pattersonCanvas = document.getElementById('patterson-canvas');
            const diffractionCanvas = document.getElementById('diffraction-canvas');
            const ftCanvas = document.getElementById('ft-canvas');
            const clearBtn = document.getElementById('clear-btn');
            const atomList = document.getElementById('atom-list');
            const noAtomsMsg = document.getElementById('no-atoms-msg');
            const atomTypeSelector = document.getElementById('atom-type-selector');
            const vectorInfoBox = document.getElementById('vector-info-box');
            
            const faSlider = document.getElementById('fa-slider');
            const faValue = document.getElementById('fa-value');
            const fbSlider = document.getElementById('fb-slider');
            const fbValue = document.getElementById('fb-value');

            const hkRangeSlider = document.getElementById('hk-range-slider');
            const hkRangeValue = document.getElementById('hk-range-value');
            const toggleHkLabels = document.getElementById('toggle-hk-labels');
            const spotSizeSlider = document.getElementById('spot-size-slider');
            const spotSizeValue = document.getElementById('spot-size-value');

            const realCtx = realCanvas.getContext('2d');
            const pattersonCtx = pattersonCanvas.getContext('2d');
            const diffractionCtx = diffractionCanvas.getContext('2d');
            const ftCtx = ftCanvas.getContext('2d');

            const FT_RESOLUTION = 128;
            const ftOffscreenCanvas = document.createElement('canvas');
            ftOffscreenCanvas.width = FT_RESOLUTION;
            ftOffscreenCanvas.height = FT_RESOLUTION;
            const ftOffscreenCtx = ftOffscreenCanvas.getContext('2d');

            // --- STATE MANAGEMENT ---
            let atoms = [];
            let pattersonPeaks = [];
            let diffractionIntensities = [];
            let ftImageData = null;
            let highlightedVector = null;
            let currentAtomType = 'A';
            let diffractionGridSize = 10; // Default h,k Range = 10
            let showHkLabels = false;    // Default Show Labels = false
            let diffractionSpotSizeFactor = 5;
            let scatteringFactors = { 'A': 6, 'B': 29 };

            // --- CONSTANTS ---
            const ATOM_COLOR_A = '#3b82f6';
            const ATOM_COLOR_B = '#ef4444';
            const HIGHLIGHT_COLOR_1 = '#db2777';
            const HIGHLIGHT_COLOR_2 = '#c026d3';
            const VECTOR_COLOR = '#7e22ce';
            const ORIGIN_PEAK_COLOR = '#f59e0b';
            const MIN_ATOM_RADIUS = 3;
            const MAX_ATOM_RADIUS = 15;
            
            // Patterson Peak Constants
            const MIN_PEAK_RADIUS = 7; // Increased size by 75%
            const MAX_PEAK_RADIUS = 16; // Increased size by 75%
            const PEAK_COLOR_AA = '#16a34a'; // Green
            const PEAK_COLOR_BB = '#0ea5e9'; // Cyan
            const PEAK_COLOR_AB = '#f97316'; // Orange
            
            // --- CALCULATION FUNCTIONS ---
            function calculatePattersonMap() {
                pattersonPeaks = [];
                if (atoms.length === 0) return;

                let originWeight = 0;
                atoms.forEach(atom => {
                    const f = scatteringFactors[atom.type];
                    originWeight += f * f;
                });

                const originPeak = { weight: originWeight, from: -1, to: -1, isOrigin: true };
                pattersonPeaks.push({ u: 0, v: 0, ...originPeak });
                pattersonPeaks.push({ u: 1, v: 0, ...originPeak });
                pattersonPeaks.push({ u: 0, v: 1, ...originPeak });
                pattersonPeaks.push({ u: 1, v: 1, ...originPeak });

                for (let i = 0; i < atoms.length; i++) {
                    for (let j = 0; j < atoms.length; j++) {
                        if (i === j) continue;

                        let u = atoms[j].x - atoms[i].x;
                        let v = atoms[j].y - atoms[i].y;

                        u = (u % 1 + 1) % 1;
                        v = (v % 1 + 1) % 1;
                        
                        const fromType = atoms[i].type;
                        const toType = atoms[j].type;
                        const vectorType = [fromType, toType].sort().join(''); // Creates 'AA', 'AB', or 'BB'
                        
                        const weight = scatteringFactors[fromType] * scatteringFactors[toType];
                        pattersonPeaks.push({ u, v, from: i, to: j, weight, isOrigin: false, vectorType });
                    }
                }
                
                let maxWeight = Math.max(...pattersonPeaks.map(p => p.weight), 0);
                pattersonPeaks.forEach(peak => {
                    const weightRatio = maxWeight > 0 ? peak.weight / maxWeight : 0;
                    peak.radius = MIN_PEAK_RADIUS + weightRatio * (MAX_PEAK_RADIUS - MIN_PEAK_RADIUS);
                });
            }

            function calculateDiffractionPattern() {
                diffractionIntensities = [];
                if (atoms.length === 0) return;
                for (let h = -diffractionGridSize; h <= diffractionGridSize; h++) {
                    for (let k = -diffractionGridSize; k <= diffractionGridSize; k++) {
                        let F_real = 0, F_imag = 0;
                        atoms.forEach(atom => {
                            const phase = 2 * Math.PI * (h * atom.x + k * atom.y);
                            const f = scatteringFactors[atom.type];
                            F_real += f * Math.cos(phase);
                            F_imag += f * Math.sin(phase);
                        });
                        const intensity = F_real * F_real + F_imag * F_imag;
                        diffractionIntensities.push({ h, k, intensity: (intensity < 1e-5) ? 0 : intensity });
                    }
                }
            }

            function calculateFTofIntensities() {
                if (diffractionIntensities.length === 0) {
                    ftImageData = null; return;
                }
                const size = FT_RESOLUTION;
                ftImageData = ftOffscreenCtx.createImageData(size, size);
                const pattersonGrid = [];
                
                for (let v_px = 0; v_px < size; v_px++) {
                    for (let u_px = 0; u_px < size; u_px++) {
                        const u = u_px / size;
                        const v = 1 - (v_px / size);
                        let pattersonVal = 0;
                        diffractionIntensities.forEach(spot => {
                            const phase = 2 * Math.PI * (spot.h * u + spot.k * v);
                            pattersonVal += spot.intensity * Math.cos(phase);
                        });
                        pattersonGrid.push(pattersonVal);
                    }
                }

                if (pattersonGrid.length === 0) return;
                const originPeakValue = Math.max(...pattersonGrid);

                let maxNonOriginPeakValue = 1;
                for (const val of pattersonGrid) {
                    if (val < originPeakValue * 0.999 && val > maxNonOriginPeakValue) {
                        maxNonOriginPeakValue = val;
                    }
                }
                
                for (let i = 0; i < pattersonGrid.length; i++) {
                    const normalizedVal = pattersonGrid[i] > 0 && maxNonOriginPeakValue > 0 
                        ? Math.min(255, Math.floor(255 * (pattersonGrid[i] / maxNonOriginPeakValue))) 
                        : 0;
                    const pixelIndex = i * 4;
                    ftImageData.data[pixelIndex] = normalizedVal;
                    ftImageData.data[pixelIndex+1] = normalizedVal;
                    ftImageData.data[pixelIndex+2] = normalizedVal;
                    ftImageData.data[pixelIndex+3] = 255;
                }
            }

            // --- DRAWING FUNCTIONS ---
            function resizeCanvases() {
                [realCanvas, pattersonCanvas, diffractionCanvas, ftCanvas].forEach(canvas => {
                    const wrapper = canvas.parentElement;
                    if (wrapper && wrapper.clientWidth > 0) {
                        const size = wrapper.clientWidth;
                        canvas.width = size; canvas.height = size;
                    }
                });
                redrawAll();
            }

            function drawAxisLabels(yId, xId, centered, isDiffraction, theme) {
                const yEl = document.getElementById(yId), xEl = document.getElementById(xId);
                yEl.innerHTML = ''; xEl.innerHTML = '';
                const textColor = theme === 'dark' ? 'text-gray-400' : 'text-gray-500';
                yEl.className = `w-8 flex-shrink-0 y-axis-labels flex flex-col justify-between text-right text-xs pr-1 ${textColor}`;
                xEl.className = `x-axis-labels flex justify-between text-center text-xs pt-1 ${textColor}`;
                for (let i = 0; i <= 5; i++) {
                    const ySpan = document.createElement('span'), xSpan = document.createElement('span');
                    let yVal = centered ? 1 - (i / 5) * 2 : 1.0 - (i / 5);
                    ySpan.textContent = isDiffraction ? Math.round(yVal * diffractionGridSize) : yVal.toFixed(1);
                    yEl.appendChild(ySpan);
                    let xVal = centered ? -1 + (i / 5) * 2 : i / 5;
                    xSpan.textContent = isDiffraction ? Math.round(xVal * diffractionGridSize) : xVal.toFixed(1);
                    xEl.appendChild(xSpan);
                }
            }
            
            function drawGridOnCanvas(ctx, theme = 'light') {
                const size = ctx.canvas.width;
                const bgColor = theme === 'dark' ? 'black' : '#f8fafc';
                const gridColor = theme === 'dark' ? '#4a4a4a' : '#e2e8f0';
                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, size, size);
                ctx.strokeStyle = gridColor;
                ctx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    const pos = i * size / 10;
                    ctx.beginPath(); ctx.moveTo(pos, 0); ctx.lineTo(pos, size); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, pos); ctx.lineTo(size, pos); ctx.stroke();
                }
            }

            function drawDiffractionGrid(ctx, theme = 'dark') {
                const size = ctx.canvas.width;
                const bgColor = theme === 'dark' ? 'black' : '#f8fafc';
                const gridColor = theme === 'dark' ? '#374151' : '#e5e7eb';
                const axisColor = theme === 'dark' ? '#6b7280' : '#d1d5db';
                const center = size / 2;
                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, size, size);
                ctx.strokeStyle = gridColor;
                ctx.lineWidth = 0.5;
                for (let i = 1; i <= diffractionGridSize; i++) {
                    let pos = center + (i / diffractionGridSize) * center;
                    ctx.beginPath(); ctx.moveTo(pos, 0); ctx.lineTo(pos, size); ctx.stroke();
                    pos = center - (i / diffractionGridSize) * center;
                    ctx.beginPath(); ctx.moveTo(pos, 0); ctx.lineTo(pos, size); ctx.stroke();
                }
                 for (let i = 1; i <= diffractionGridSize; i++) {
                    let pos = center + (i / diffractionGridSize) * center;
                    ctx.beginPath(); ctx.moveTo(0, pos); ctx.lineTo(size, pos); ctx.stroke();
                    pos = center - (i / diffractionGridSize) * center;
                    ctx.beginPath(); ctx.moveTo(0, pos); ctx.lineTo(size, pos); ctx.stroke();
                }
                ctx.strokeStyle = axisColor;
                ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(center, 0); ctx.lineTo(center, size); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, center); ctx.lineTo(size, center); ctx.stroke();
            }

            function getAtomRadius(type) {
                const normalized = (scatteringFactors[type] - 1) / 79;
                return MIN_ATOM_RADIUS + normalized * (MAX_ATOM_RADIUS - MIN_ATOM_RADIUS);
            }

            function drawAtoms() {
                drawGridOnCanvas(realCtx);
                const size = realCanvas.width;
                atoms.forEach((atom, index) => {
                    for (let i = -1; i <= 1; i++) {
                        for (let j = -1; j <= 1; j++) {
                            const x_periodic = atom.x + i;
                            const y_periodic = atom.y + j;
                            const x_canvas = x_periodic * size;
                            const y_canvas = (1 - y_periodic) * size;
                            const radius = getAtomRadius(atom.type);
                            if (x_canvas > -radius && x_canvas < size + radius && y_canvas > -radius && y_canvas < size + radius) {
                                realCtx.save();
                                realCtx.fillStyle = atom.type === 'A' ? ATOM_COLOR_A : ATOM_COLOR_B;
                                realCtx.strokeStyle = 'white';
                                realCtx.lineWidth = 2;
                                if (highlightedVector) {
                                    if (index === highlightedVector.from) realCtx.fillStyle = HIGHLIGHT_COLOR_1;
                                    else if (index === highlightedVector.to) realCtx.fillStyle = HIGHLIGHT_COLOR_2;
                                }
                                realCtx.beginPath();
                                realCtx.arc(x_canvas, y_canvas, radius, 0, 2 * Math.PI);
                                realCtx.fill();
                                realCtx.stroke();
                                realCtx.restore();
                            }
                        }
                    }
                });
                if (highlightedVector) {
                    const fromAtom = atoms[highlightedVector.from];
                    const toAtom = atoms[highlightedVector.to];
                    if (fromAtom && toAtom) {
                        realCtx.strokeStyle = VECTOR_COLOR;
                        realCtx.lineWidth = 2.5;
                        realCtx.lineCap = 'round';
                        realCtx.beginPath();
                        realCtx.moveTo(fromAtom.x * size, (1-fromAtom.y) * size);
                        realCtx.lineTo(toAtom.x * size, (1-toAtom.y) * size);
                        realCtx.stroke();
                        const angle = Math.atan2((1-toAtom.y) * size - (1-fromAtom.y) * size, toAtom.x * size - fromAtom.x * size);
                        realCtx.fillStyle = VECTOR_COLOR;
                        realCtx.save();
                        realCtx.translate(toAtom.x * size, (1-toAtom.y) * size);
                        realCtx.rotate(angle);
                        realCtx.beginPath();
                        realCtx.moveTo(0, 0); realCtx.lineTo(-10, -5); realCtx.lineTo(-10, 5);
                        realCtx.closePath(); realCtx.fill();
                        realCtx.restore();
                    }
                }
            }

            function drawPattersonMap() {
                drawGridOnCanvas(pattersonCtx);
                const size = pattersonCanvas.width;

                pattersonPeaks.forEach(peak => {
                    const isHighlighted = highlightedVector && peak.from === highlightedVector.from && peak.to === highlightedVector.to && Math.abs(peak.u - highlightedVector.u) < 1e-9 && Math.abs(peak.v - highlightedVector.v) < 1e-9;
                    
                    if (peak.isOrigin) {
                        pattersonCtx.fillStyle = ORIGIN_PEAK_COLOR;
                    } else {
                        switch (peak.vectorType) {
                            case 'AA':
                                pattersonCtx.fillStyle = PEAK_COLOR_AA;
                                break;
                            case 'BB':
                                pattersonCtx.fillStyle = PEAK_COLOR_BB;
                                break;
                            case 'AB':
                                pattersonCtx.fillStyle = PEAK_COLOR_AB;
                                break;
                        }
                    }
                    if (isHighlighted) pattersonCtx.fillStyle = VECTOR_COLOR;
                    
                    pattersonCtx.strokeStyle = 'white';
                    pattersonCtx.lineWidth = 2;
                    pattersonCtx.beginPath();
                    const u_canvas = peak.u === 1 ? size : peak.u * size;
                    const v_canvas = peak.v === 1 ? 0 : (1 - peak.v) * size;
                    pattersonCtx.arc(u_canvas, v_canvas, peak.radius, 0, 2 * Math.PI);
                    pattersonCtx.fill();
                    pattersonCtx.stroke();
                });

                if (highlightedVector) {
                    pattersonCtx.fillStyle = '#1e293b';
                    pattersonCtx.font = 'bold 12px Inter';
                    const text = `(${highlightedVector.u.toFixed(2)}, ${highlightedVector.v.toFixed(2)})`;
                    const xPos = highlightedVector.u * size + 10;
                    const yPos = (1 - highlightedVector.v) * size;
                    pattersonCtx.textAlign = 'left';
                    pattersonCtx.textBaseline = 'middle';
                    pattersonCtx.fillText(text, xPos, yPos);
                }
            }

            function drawDiffractionPattern() {
                drawDiffractionGrid(diffractionCtx, 'dark');
                const size = diffractionCanvas.width;
                const center = size / 2;
                
                let maxIntensity = Math.max(1e-9, ...diffractionIntensities.filter(s => s.h || s.k).map(s => s.intensity));
                
                const maxSqrtIntensity = Math.sqrt(maxIntensity);

                diffractionIntensities.forEach(spot => {
                    if ((!spot.h && !spot.k) || !spot.intensity) return;

                    const normalizedIntensity = maxSqrtIntensity > 0 ? Math.sqrt(spot.intensity) / maxSqrtIntensity : 0;

                    if (normalizedIntensity < 0.01) return;

                    const radius = 1 + diffractionSpotSizeFactor * normalizedIntensity;
                    const x = center + (spot.h / diffractionGridSize) * center;
                    const y = center - (spot.k / diffractionGridSize) * center;
                    
                    const colorValue = Math.floor(200 * normalizedIntensity) + 55;
                    diffractionCtx.fillStyle = `rgb(${colorValue}, ${colorValue}, ${colorValue})`;
                    diffractionCtx.beginPath();
                    diffractionCtx.arc(x, y, radius, 0, 2 * Math.PI);
                    diffractionCtx.fill();
                });

                if (showHkLabels) {
                    diffractionCtx.fillStyle = '#fbbf24';
                    diffractionCtx.font = '10px Inter';
                    diffractionCtx.textAlign = 'center';
                    diffractionCtx.textBaseline = 'middle';
                    
                    diffractionIntensities.forEach(spot => {
                        if (spot.h === 0 && spot.k === 0) return;
                        
                        const normalizedIntensity = maxSqrtIntensity > 0 ? Math.sqrt(spot.intensity) / maxSqrtIntensity : 0;

                        if (normalizedIntensity < 0.15) return;
                        const x = center + (spot.h / diffractionGridSize) * center;
                        const y = center - (spot.k / diffractionGridSize) * center;
                        diffractionCtx.fillText(`${spot.h},${spot.k}`, x, y - 12);
                    });
                }
                diffractionCtx.fillStyle = '#ef4444';
                diffractionCtx.fillText('0,0', center, center - 10);
            }

            function drawFTofIntensities() {
                drawGridOnCanvas(ftCtx, 'dark');
                if (ftImageData) {
                    ftOffscreenCtx.putImageData(ftImageData, 0, 0);
                    ftCtx.imageSmoothingEnabled = false;
                    ftCtx.drawImage(ftOffscreenCanvas, 0, 0, ftCanvas.width, ftCanvas.height);
                }
            }
            
            function updateAtomList() {
                const activeId = document.activeElement ? document.activeElement.id : null;
                atomList.innerHTML = '';
                noAtomsMsg.style.display = atoms.length === 0 ? 'block' : 'none';
                atoms.forEach((atom, index) => {
                    const li = document.createElement('li');
                    li.className = 'flex justify-between items-center bg-gray-700 p-2 rounded-md border border-gray-600';
                    const isHighlighted = highlightedVector && (index === highlightedVector.from || index === highlightedVector.to);
                    if(isHighlighted) {
                        li.style.backgroundColor = index === highlightedVector.from ? '#581c87' : '#5b21b6';
                    }
                    li.innerHTML = `
                        <div class="flex items-center gap-2 font-mono text-sm text-gray-300">
                            <span>${index + 1}(${atom.type}): (</span>
                            <input type="number" step="0.01" min="0" max="1" value="${atom.x.toFixed(2)}" id="atom-${index}-x" data-index="${index}" data-coord="x" class="coord-input">,
                            <input type="number" step="0.01" min="0" max="1" value="${atom.y.toFixed(2)}" id="atom-${index}-y" data-index="${index}" data-coord="y" class="coord-input">
                            <span>)</span>
                        </div>
                        <button data-index="${index}" class="remove-atom-btn text-red-500 hover:text-red-400 text-xs font-semibold">REMOVE</button>
                    `;
                    atomList.appendChild(li);
                });
                if (activeId) document.getElementById(activeId)?.focus();
            }

            function updateVectorInfo() {
                if (!highlightedVector) {
                    vectorInfoBox.innerHTML = 'Hover over a Patterson peak...'; return;
                }
                const fromAtom = atoms[highlightedVector.from];
                const toAtom = atoms[highlightedVector.to];
                if (!fromAtom || !toAtom) return;
                let real_u = toAtom.x - fromAtom.x;
                let real_v = toAtom.y - fromAtom.y;
                vectorInfoBox.innerHTML = `
                    <div class="space-y-1">
                        <div><span class="text-pink-400">From Atom ${highlightedVector.from + 1} (x₁,y₁):</span> (${fromAtom.x.toFixed(3)}, ${fromAtom.y.toFixed(3)})</div>
                        <div><span class="text-purple-400">To Atom ${highlightedVector.to + 1} (x₂,y₂):</span> (${toAtom.x.toFixed(3)}, ${toAtom.y.toFixed(3)})</div>
                        <div class="pt-2">
                           <div>u = x₂-x₁ = ${real_u.toFixed(3)}</div>
                           <div>v = y₂-y₁ = ${real_v.toFixed(3)}</div>
                        </div>
                        <div class="font-bold pt-2"><span class="text-indigo-400">Peak (u,v):</span> (${highlightedVector.u.toFixed(3)}, ${highlightedVector.v.toFixed(3)})</div>
                    </div>
                `;
            }

            function redrawAll() {
                calculatePattersonMap();
                calculateDiffractionPattern();
                calculateFTofIntensities();
                updateAtomList();
                updateVectorInfo();
                drawAxisLabels('real-y-axis', 'real-x-axis', false, false, 'light');
                drawAtoms();
                drawAxisLabels('patterson-y-axis', 'patterson-x-axis', false, false, 'light');
                drawPattersonMap();
                drawAxisLabels('diffraction-y-axis', 'diffraction-x-axis', true, true, 'dark');
                drawDiffractionPattern();
                drawAxisLabels('ft-y-axis', 'ft-x-axis', false, false, 'dark');
                drawFTofIntensities();
            }

            // --- EVENT HANDLERS ---
            function handleAtomTypeChange(event) {
                if (event.target.name === 'atom-type') currentAtomType = event.target.value;
            }
            function handleAddAtom(event) {
                const rect = realCanvas.getBoundingClientRect();
                const x = (event.clientX - rect.left) / rect.width;
                const y = 1 - ((event.clientY - rect.top) / rect.height);
                if (x >= 0 && x <= 1 && y >= 0 && y <= 1) {
                    atoms.push({ x, y, type: currentAtomType });
                    redrawAll();
                }
            }
            function handleAtomListInteraction(event) {
                if (event.target.classList.contains('remove-atom-btn')) {
                    const indexToRemove = parseInt(event.target.dataset.index, 10);
                    atoms.splice(indexToRemove, 1);
                    highlightedVector = null; 
                    redrawAll();
                }
            }
            function handleCoordinateChange(event) {
                if (event.target.classList.contains('coord-input')) {
                    const index = parseInt(event.target.dataset.index, 10);
                    const coord = event.target.dataset.coord;
                    let value = parseFloat(event.target.value) || 0;
                    value = (value % 1 + 1) % 1;
                    event.target.value = value.toFixed(2);
                    if (atoms[index]) {
                        atoms[index][coord] = value;
                        redrawAll();
                    }
                }
            }
            function handlePattersonHover(event) {
                const rect = pattersonCanvas.getBoundingClientRect();
                const mouseU = (event.clientX - rect.left) / rect.width;
                const mouseV = 1 - ((event.clientY - rect.top) / rect.height);
                let foundPeak = null;
                let minDistance = Infinity;
                const hoverThreshold = (MAX_PEAK_RADIUS * 2) / rect.width;
                for (const peak of pattersonPeaks) {
                     const dist = Math.sqrt(Math.pow(peak.u - mouseU, 2) + Math.pow(peak.v - mouseV, 2));
                     if (dist < hoverThreshold && dist < minDistance) {
                        if (!peak.isOrigin) {
                            minDistance = dist;
                            foundPeak = peak;
                        }
                     }
                }
                if (JSON.stringify(foundPeak) !== JSON.stringify(highlightedVector)) {
                    highlightedVector = foundPeak;
                    redrawAll();
                }
            }
            function clearAll() {
                atoms = [];
                highlightedVector = null;
                redrawAll();
            }
            function handleScatteringFactorChange(event) {
                const val = parseInt(event.target.value, 10);
                if (event.target.id === 'fa-slider') {
                    scatteringFactors.A = val;
                    faValue.textContent = val;
                } else {
                    scatteringFactors.B = val;
                    fbValue.textContent = val;
                }
                redrawAll();
            }
            function handleHkRangeChange(event) {
                diffractionGridSize = parseInt(event.target.value, 10);
                hkRangeValue.textContent = diffractionGridSize;
                redrawAll();
            }
            function handleToggleHkLabels(event) {
                showHkLabels = event.target.checked;
                drawDiffractionPattern();
            }
            function handleSpotSizeChange(event) {
                diffractionSpotSizeFactor = parseInt(event.target.value, 10);
                spotSizeValue.textContent = diffractionSpotSizeFactor;
                drawDiffractionPattern();
            }

            const leftPanel = document.getElementById('controls-panel'), resizer = document.getElementById('drag-handle');
            resizer.addEventListener('mousedown', (e) => {
                e.preventDefault(); document.body.classList.add('resizing');
                const moveHandler = (e) => { if (e.clientX > 350 && e.clientX < 550) leftPanel.style.width = `${e.clientX}px`; };
                const upHandler = () => {
                    document.body.classList.remove('resizing');
                    window.removeEventListener('mousemove', moveHandler); window.removeEventListener('mouseup', upHandler);
                    setTimeout(resizeCanvases, 50);
                };
                window.addEventListener('mousemove', moveHandler); window.addEventListener('mouseup', upHandler);
            });
            
            atomTypeSelector.addEventListener('change', handleAtomTypeChange);
            realCanvas.addEventListener('click', handleAddAtom);
            clearBtn.addEventListener('click', clearAll);
            atomList.addEventListener('click', handleAtomListInteraction);
            atomList.addEventListener('change', handleCoordinateChange);
            pattersonCanvas.addEventListener('mousemove', handlePattersonHover);
            pattersonCanvas.addEventListener('mouseleave', () => {
                if (highlightedVector) {
                    highlightedVector = null;
                    redrawAll();
                }
            });
            faSlider.addEventListener('input', handleScatteringFactorChange);
            fbSlider.addEventListener('input', handleScatteringFactorChange);
            hkRangeSlider.addEventListener('input', handleHkRangeChange);
            toggleHkLabels.addEventListener('change', handleToggleHkLabels);
            spotSizeSlider.addEventListener('input', handleSpotSizeChange);
            window.addEventListener('resize', () => setTimeout(resizeCanvases, 50));
            
            setTimeout(resizeCanvases, 100);
        });
    </script>
</body>
</html>